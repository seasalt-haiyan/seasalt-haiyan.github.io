<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript中的事件循环</title>
    <link href="/2024/04/19/JavaScript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2024/04/19/JavaScript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="线程与进程">线程与进程</h2><ul class="lvl-0"><li class="lvl-2">进程（process）</li></ul><p>保存在硬盘中的程序会被载入到内存中运行，在内存空间里面形成一个独立的内存体，这个内存体由自己独立的地址空间、系统也会为应用的每一个进程分配独立的CPU、内存等资源</p><ul class="lvl-0"><li class="lvl-2"><p>线程（thread）</p></li></ul><p>进程中执行的每一个任务指的就是线程，系统不会为其分配内存资源，各个线程共享进程拥有的内存资源</p><p><strong>进程是CPU资源分配的最小单位</strong></p><p><strong>线程是CPU调度的最小单位</strong></p><h2 id="事件循环是什么">事件循环是什么</h2><p>JavaScript 是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环</p><p>在JS中，所有的任务都可以分为</p><ul class="lvl-0"><li class="lvl-2"><p>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中进行</p></li><li class="lvl-2"><p>异步任务：异步执行的任务，比如ajax请求，定时器等</p></li></ul><p>同步任务和异步任务的运行流程图如下：<br><img src="https://static.vue-js.com/61efbc20-7cb8-11eb-85f6-6fac77c0c9b3.png" alt=""></p><p>同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内任务执行完毕后，去任务队列读取对应的任务并且推入主线程执行，上述过程的重复就是事件循环</p><ol><li class="lvl-3"><p>首先判断js代码是同步还是异步,同步就进入主线程，异步就进入event table</p></li><li class="lvl-3"><p>异步任务在event table中注册函数，当满足触发条件后，被推入event queue</p></li><li class="lvl-3"><p>同步任务进入主线程后一直执行，直到主线程空闲时，才回去event quene中查看是否有可执行的异步任务，如果有就推入主线程中</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>event table(回调函数对应表)：用来存储JS中的异步事件(request, setTimeout,IO等)及其对应的回调函数列表</p></li></ul><h2 id="宏任务和微任务">宏任务和微任务</h2><p>为什么引入微任务？</p><p>异步任务也有优先级之分，例如DOM操作如果等待过久给用户的体验不好</p><p>所以JS的执行机制是：</p><ul class="lvl-0"><li class="lvl-2"><p>执行一个宏任务，如果遇到微任务就把它放到微任务的事件队列中</p></li><li class="lvl-2"><p>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完<br><img src="https://static.vue-js.com/6e80e5e0-7cb8-11eb-85f6-6fac77c0c9b3.png" alt=""></p></li></ul><h3 id="常见的宏任务">常见的宏任务</h3><ul class="lvl-0"><li class="lvl-2"><p>script</p></li><li class="lvl-2"><p>setTimeout</p></li><li class="lvl-2"><p>setInterval</p></li><li class="lvl-2"><p>UI rendering</p></li><li class="lvl-2"><p>I/O (node.js)</p></li><li class="lvl-2"><p>setImmediate (node.js)</p></li></ul><h3 id="常见的微任务">常见的微任务</h3><ul class="lvl-0"><li class="lvl-2"><p>Promise.then</p></li><li class="lvl-2"><p>MutaionObserver</p></li><li class="lvl-2"><p>process.nextTick(node.js)</p></li></ul><h2 id="async-和-await">async 和 await</h2><p><code>async</code>是异步的意思，<code>await</code>则可以理解为 <code>async await</code>。所以可以理解为<code>async</code>就是用来声明一个异步方法，而<code>await</code>是用来等待异步方法执行</p><h3 id="async">async</h3><p><code>async</code>函数返回一个<code>promise</code>对象，下面两种方法是等效的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;TEST&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncF</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;TEST&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="await">await</h3><p>正常情况下，<code>await</code>命令后面是一个<code>Promise</code>对象，返回该对象的结果，如果不是<code>Promise</code>对象，就直接返回对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-number">123</span>;<br>    <span class="hljs-comment">//等同于 return 123</span><br>&#125;<br><span class="hljs-title function_">f</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v)) <span class="hljs-comment">//123</span><br></code></pre></td></tr></table></figure><p>不管<code>await</code>后面跟着什么，<code>await</code>都会阻塞后面的代码(即加入微任务队列)</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中的闭包</title>
    <link href="/2024/04/18/JS%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <url>/2024/04/18/JS%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="闭包是什么？">闭包是什么？</h2><p>一个函数和对其周围状态(lexical environment, 词法环境)的引用捆绑在一起(或者说函数被引用包围)，这样的组合就是闭包。</p><p>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域</p><p>在JS中，每创建一个函数，闭包就会在函数创建的同时创建出来，作为函数内部与外部连接起来的一座桥梁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Mozilla&quot;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">displayName</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(name);<br>    &#125;<br>    <span class="hljs-title function_">displayName</span>();<br>&#125;<br><span class="hljs-title function_">init</span>();<br></code></pre></td></tr></table></figure><p><code>displayName()</code>函数没有自己的局部变量。然后，由于闭包的特性，他可以访问到外部函数的变量</p><p>《你不知道的JavaScript》: 当函数可以记住并访问所在的词法作用域时，就产生了闭包</p><p><strong>词法作用域</strong>：指的是定义表达式并能被访问的区间，也就是一个声明（定义变量、函数等）的词法作用域就是它被<strong>定义</strong>时所在的作用域</p><h2 id="闭包的经典使用场景">闭包的经典使用场景</h2><ul class="lvl-0"><li class="lvl-2"><p>return 回一个函数</p></li><li class="lvl-2"><p>函数作为一个参数</p></li><li class="lvl-2"><p>循环赋值</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = []<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>  data[i] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>;i++)&#123;<br>  data[i]();<br>&#125;<br><span class="hljs-comment">//0 1 2 3 4</span><br><span class="hljs-keyword">var</span> data = []<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>  data[i] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>;j++)&#123;<br>  data[j]()<br>&#125;<br><span class="hljs-comment">//0 1 2 3 4</span><br><span class="hljs-keyword">var</span> data = []<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++)&#123;<br>  data[i] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; i = <span class="hljs-number">9</span>; j &lt; <span class="hljs-number">5</span>; j++)&#123;<br>  data[j]();<br>&#125;<br><span class="hljs-comment">//0 1 2 3 4</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>防抖、节流</p></li></ul><h2 id="闭包的危害">闭包的危害</h2><ul class="lvl-0"><li class="lvl-2"><p>容易造成内存泄漏</p></li></ul><p>内层函数调用的外部变量无法得到释放，会产生内存泄漏</p><p>如果不是某些特定任务需要使用闭包，在其他函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS函数中的this</title>
    <link href="/2024/04/18/JS%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this/"/>
    <url>/2024/04/18/JS%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this/</url>
    
    <content type="html"><![CDATA[<h2 id="this-的定义">this 的定义</h2><p>JavaScript 函数中的<code>this</code> 关键字与其他语言略有不同，此外，在严格模式和非严格模式之间也会有一些差别</p><p>在绝大多数情况下，函数的调用方式决定了<code>this</code>的值 <strong>(运行时绑定)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//当前调用栈：baz </span><br>    <span class="hljs-comment">//全局作用域</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;baz&quot;</span>);<br>    <span class="hljs-title function_">bar</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//当前调用栈 baz=&gt;bar</span><br>    <span class="hljs-comment">//当前调用位置在baz中</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar&quot;</span>);<br>    <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//当前调用栈 baz=&gt;bar=&gt;foo</span><br>    <span class="hljs-comment">//当前调用位置在bar中</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">baz</span>();<br></code></pre></td></tr></table></figure><p>要先弄懂调用位置才能更好的理解<code>this</code>，同时，<code>this</code>一旦被确定了，就<strong>不可以被更改</strong></p><h2 id="绑定规则（重要）">绑定规则（重要）</h2><p>根据不同的使用场合，this有不同的值，主要有下面几种情况</p><ul class="lvl-0"><li class="lvl-2"><p>默认绑定</p></li><li class="lvl-2"><p>隐式绑定</p></li><li class="lvl-2"><p>new绑定</p></li><li class="lvl-2"><p>显式绑定</p></li></ul><h3 id="默认绑定">默认绑定</h3><p>无法应用其他规则时使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Jenny&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">person</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">person</span>());<span class="hljs-comment">//Jenny</span><br></code></pre></td></tr></table></figure><p>this指向全局对象<code>window</code>，严格模式下绑定到<code>undefined</code></p><h3 id="隐式绑定">隐式绑定</h3><p>函数还可以作为某个对象的方法调用，这时<code>this</code>就指这个上级对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">x</span> = <span class="hljs-number">1</span>;<br>obj.<span class="hljs-property">m</span> = test;<br><br>obj.<span class="hljs-property">m</span> = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//obj调用的函数，this绑定到obj上，所以相当于obj.x</span><br></code></pre></td></tr></table></figure><p>如果是嵌套对象调用，<code>this</code>依然指向<strong>上一级</strong>的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">10</span>,<br>    <span class="hljs-attr">b</span>:&#123;<br>        <span class="hljs-attr">fn</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>        &#125;<br>    &#125;<br>&#125;<br>o.<span class="hljs-property">b</span>.<span class="hljs-title function_">fn</span>();<br><span class="hljs-comment">//上一级对象为b，b里面没有a属性，所以输出undefined</span><br></code></pre></td></tr></table></figure><p>一种特殊情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o =&#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">b</span>:&#123;<br>        <span class="hljs-attr">a</span>:<span class="hljs-number">12</span>,<br>        <span class="hljs-attr">fn</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<span class="hljs-comment">//undefined window中没有变量a</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">//window </span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> j = o.<span class="hljs-property">b</span>.<span class="hljs-property">fn</span>;<br><span class="hljs-title function_">j</span>();<br><span class="hljs-comment">//this -&gt; window</span><br></code></pre></td></tr></table></figure><p>这里的<code>this</code>是<code>window</code>，注意：this永远指向<strong>最后</strong>调用它的对象，虽然fn函数是对象b的方法，但是该函数最后在全局作用域中执行，所以最终指向<code>window</code></p><ul class="lvl-0"><li class="lvl-2"><p>隐式丢失</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">foo</span>: foo &#125;;<br><span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span>; <span class="hljs-comment">// 为函数调用创建别名</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a是全局对象的属性bar();</span><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>为foo函数创建别名bar时发生了隐式丢失，bar函数自动绑定到<code>window</code>或者<code>undefined</code>(严格模式)</p><h3 id="new-绑定">new 绑定</h3><p>通过构建函数<code>new</code>关键字生成一个实例对象，此时<code>this</code>指向这个实例对象</p><p>这和new关键字的原理有关</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">test</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">x</span>)<span class="hljs-comment">//1 obj被绑定到函数调用的this上</span><br></code></pre></td></tr></table></figure><p>列举一些特殊情况</p><p><code>new</code>过程中遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">user</span>)<span class="hljs-comment">//undefined</span><br><span class="hljs-comment">//你可能认为this绑定到a上，实际上如果构造函数中有返回对象，则绑定函数调用this为该返回的this上，所以a.user为undefined</span><br></code></pre></td></tr></table></figure><p>如果返回的不是对象，是基本数据类型，则<code>this</code>指向为实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">user</span>);<span class="hljs-comment">//xxx</span><br><span class="hljs-comment">//返回值为number类型，则this依然绑定到a上面</span><br></code></pre></td></tr></table></figure><p>虽然null也表示对象，但是此时this依然指向实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">user</span>);<span class="hljs-comment">//xxx</span><br></code></pre></td></tr></table></figure><h3 id="显式修改">显式修改</h3><p><code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象，它的第一个参数就表示改变后的调用对象，因此，这时<code>this</code>指的就是这第一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> &#125;;<br>foo.<span class="hljs-title function_">call</span>(obj); <span class="hljs-comment">// 2 this绑定到obj上</span><br>foo.<span class="hljs-title function_">call</span>(obj1); <span class="hljs-comment">// 3 this绑定到obj1上</span><br></code></pre></td></tr></table></figure><h4 id="硬绑定">硬绑定</h4><p>硬绑定是指强制把this绑定到某个对象上(除了使用new时)</p><p><strong>注意，函数通过 bind() 方法被绑定，它的this将被永久固定</strong></p><h3 id="优先级">优先级</h3><p>new &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p><h3 id="this-特例">this 特例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b);<br>&#125;<br><span class="hljs-keyword">var</span> dmzobj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<span class="hljs-comment">//dmzoj对象是一个以null为原型的对象</span><br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(dmzobj,<span class="hljs-number">2</span>);<span class="hljs-comment">//将foo函数的this绑定到dmzoj上，bind方法返回一个具有全新this的函数</span><br><span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//2 3</span><br></code></pre></td></tr></table></figure><p>间接引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">foo</span>: foo&#125;;<br><span class="hljs-keyword">var</span> p = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">4</span> &#125;;<br>o.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">//3</span><br>(p.<span class="hljs-property">foo</span> = p.<span class="hljs-property">foo</span>)();<span class="hljs-comment">//立即执行函数 2</span><br></code></pre></td></tr></table></figure><p>软绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj&quot;</span> &#125;,<br>  obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj2&quot;</span> &#125;,<br>  obj3 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj3&quot;</span> &#125;;<br><span class="hljs-keyword">var</span> fooOBJ = foo.<span class="hljs-title function_">softBind</span>(obj);<br><span class="hljs-title function_">fooOBJ</span>(); <span class="hljs-comment">// name: obj</span><br><br>fooOBJ.<span class="hljs-title function_">call</span>(obj3); <span class="hljs-comment">// name: obj3</span><br></code></pre></td></tr></table></figure><h2 id="箭头函数的this">箭头函数的this</h2><p>箭头函数没有自己的<code>this</code>,箭头函数的<code>this</code>由外层作用域决定，(运行时绑定)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">sayThis</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">sayThis</span>();<span class="hljs-comment">//绑定obj的this 也就是window</span><br><span class="hljs-keyword">const</span> globalSay = obj.<span class="hljs-property">sayThis</span>;<br><span class="hljs-title function_">globalSay</span>();<br></code></pre></td></tr></table></figure><p><strong>箭头函数不能作为构造函数</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 盒子模型</title>
    <link href="/2024/03/05/CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/03/05/CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1>盒子模型组成</h1><ul class="lvl-0"><li class="lvl-2">border 边框</li><li class="lvl-2">content 内容</li><li class="lvl-2">padding 内边距</li><li class="lvl-2">margin 外边距</li></ul><img src="/2024/03/05/CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/1.png" class="" title="这是图片的说明"><h1>边框 border</h1><p>border可以设置元素的边框。边框由三部分组成：边框宽度（粗细）边框样式 边框颜色</p><p>语法：<br><code>border : border-width || border-style || border-color</code></p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">border-width</td><td style="text-align:center">定义边框粗细，单位是px</td></tr><tr><td style="text-align:center">border-style</td><td style="text-align:center">边框的样式</td></tr><tr><td style="text-align:center">border-color</td><td style="text-align:center">边框颜色</td></tr></tbody></table><p>边框简写</p><p><code>border: 1px solid red;</code></p><p><strong>边框会影响盒子的实际大小</strong></p><h1>内边距 padding</h1><p>内边距即边框和内容之间的距离</p><p><code>padding : 10px</code></p><p><strong>padding会影响盒子实际大小</strong></p><p>如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子</p><p>如果保证盒子和效果图大小一致，则让width/height减去多出来的内边距大小即可</p><h1>外边距 margin</h1><p>margin控制盒子与盒子之间的距离</p><p><code>margin: 10px</code></p><p>典型应用：块级盒子水平居中</p><ul class="lvl-0"><li class="lvl-2"><p>盒子必须有宽度</p></li><li class="lvl-2"><p>盒子左右的外边距都为auto</p></li><li class="lvl-2"><p><code>margin: 0 auto,</code>即可实现</p></li></ul><p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。</p><p>当上下相邻的两个块元素(兄弟关系)相遇时，如果上面的元素有下外边距 margin-bottom ，下面的元素有上外边距 margin-top 则他们的垂直边距不是两个margin之和，而是两个值中的较大者，这种现象称为相邻块元素垂直外边距的合并。</p><p>解决办法：尽量只给一个盒子添加margin</p><h1>怪异盒模型</h1><img src="/2024/03/05/CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/2.png" class="" title="这是图片的说明"><p>CSS中盒子模型包含两种: W3C标准和 IE标准盒子模型</p><p>大多数浏览器采用W3C标准模型，而IE中则采用Microsoft自己的标准</p><p>怪异模式是:“部分浏览器在支持W3C标准的同时还保留了原来的解析模式”，怪异模式主要表现在IE内核的浏览器</p><p>如图所示，怪异盒模型的宽高是包含了content、padding和border的。</p><p>在大多数情况下用到的都是标准盒模型，当然盒子模型之间也是可以相互转换的。</p><h2 id="box-sizing">box-sizing</h2><p>语法：<code>box-sizing: content-box || border-box ||inherit</code></p><ul class="lvl-0"><li class="lvl-2"><p>当设置为content-box时，将采用标准模式解析计算，也是默认模式；</p></li><li class="lvl-2"><p>当设置为border-box时，将采用怪异模式解析计算</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中的数组与字符串</title>
    <link href="/2024/03/05/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/03/05/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1>字符串</h1><p>字符串是一种基本数据类型</p><h2 id="获取字符串长度的length属性">获取字符串长度的length属性</h2><p>使用字符串的length属性可以查看当前字符串中字符的数量，双字符也会按照单字符来计算</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">str.<span class="hljs-property">length</span><br></code></pre></td></tr></table></figure><h2 id="字符串拼接-concat方法">字符串拼接 concat方法</h2><p>concat方法用于连接（合并/拼接）字符串，使用方法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">let</span> str2 = str.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;qwq&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2);<br></code></pre></td></tr></table></figure><p>字符串也可以使用加号运算符来拼接（常用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello&quot;</span>+<span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br></code></pre></td></tr></table></figure><h2 id="字符串切片方法-slice">字符串切片方法 slice</h2><p>切片方法，顾名思义，就是将字符串切成某一段的一片</p><p>它接受两个参数，第一个参数是开始的位置（必需），第二个参数是结束的位置</p><p>当传入负数时，按照从末尾开始算，-1表示倒数第一位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;一二三四五六七八&quot;</span>;<br><span class="hljs-keyword">let</span> strSplice = str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strSplice);<span class="hljs-comment">//一二三四五六</span><br></code></pre></td></tr></table></figure><h2 id="删除左右空格的trim方法">删除左右空格的trim方法</h2><p><code>trim</code>方法会返回一个新字符串，删除了左右的所有空格<br><strong>实际开发中会用到这个方法进行用户输入数据的处理</strong></p><h2 id="将字符串打碎成数组的split方法">将字符串打碎成数组的split方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;一二三四五六七八&quot;</span>;<br><span class="hljs-keyword">let</span> engStr = <span class="hljs-string">&quot;hello world you qwq&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>));<span class="hljs-comment">//&#x27;一&#x27;, &#x27;二&#x27;, &#x27;三&#x27;, &#x27;四&#x27;, &#x27;五&#x27;, &#x27;六&#x27;, &#x27;七&#x27;, &#x27;八&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(engStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>));<span class="hljs-comment">//&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;you&#x27;, &#x27;qwq&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="字符串的大小写转换方法-toLowCase-toUpperCase">字符串的大小写转换方法 toLowCase toUpperCase</h2><p>返回一个新字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sentence = <span class="hljs-string">&#x27;The quick brown fox jumps over the lazy dog.&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sentence.<span class="hljs-title function_">toUpperCase</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sentence.<span class="hljs-title function_">toLowCase</span>());<br></code></pre></td></tr></table></figure><h1>数组</h1><p>数组是一种复合数据类型，在数组中可以存储多个不同类型的数据</p><p>数据中存储的是有序的数据，对象存储的是无序的数据，数组中每个数都有一个唯一的索引</p><ul class="lvl-0"><li class="lvl-2"><p>索引是一组大于等于0的整数</p></li><li class="lvl-2"><p>创建数组</p><ul class="lvl-2"><li class="lvl-4">可以通过Array()，也可以通过数组字面量来创建数组</li></ul></li><li class="lvl-2"><p>向数组中添加元素</p><ul class="lvl-2"><li class="lvl-4"><code>数组[索引] = 元素</code></li></ul></li><li class="lvl-2"><p>length属性</p><ul class="lvl-2"><li class="lvl-4">获取数组中元素的数量，实际值为数组索引+1，length值可以修改，可以使用length向数组末尾添加元素</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>;<br><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<span class="hljs-comment">//数组字面量</span><br><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">22</span>;<br><br><span class="hljs-title function_">typeof</span>(arr)<span class="hljs-comment">//object</span><br><br>arr2.<span class="hljs-property">length</span> <span class="hljs-comment">//5</span><br><br>arr[arr.<span class="hljs-property">length</span>] = <span class="hljs-number">5</span> <span class="hljs-comment">//末尾添加</span><br></code></pre></td></tr></table></figure><h2 id="数组的迭代">数组的迭代</h2><p>JS中的数组有自己的迭代方式，不需要我们手动使用for循环遍历</p><ul class="lvl-0"><li class="lvl-2"><p>forEach方法：</p></li></ul><p><code>forEach()</code>方法没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;);<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>map方法</p></li></ul><p><code>map</code>方法是带有返回值的方法，并且<code>map</code>方法比<code>forEach()</code>要快，他会返回一个新的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">let</span> arrNew = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item + <span class="hljs-number">1</span>;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//1，2，3，4，5，6</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrNew);<span class="hljs-comment">//2，3，4，5，6，7</span><br></code></pre></td></tr></table></figure><h2 id="数组中查找某个元素的位置indexOf">数组中查找某个元素的位置indexOf</h2><p><code>indexOf(item，start)</code>方法可以返回数组中某个指定的元素位置。该方法将从头到尾地检索数组，看它是否含有对应的元素，开始检索的位置在数组 start 处或数组的开头（没有指定 start 参数时）。如果找到一个 item，则返回 item 的第一次出现的位置。如果在数组中没找到指定元素则返回 -1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-keyword">let</span> index = fruits.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;Apple&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index);<br><br></code></pre></td></tr></table></figure><h2 id="数组的过滤方法filter">数组的过滤方法filter</h2><p><code>fliter</code>方法用于对数组进行过滤，他会<strong>创建一个新数组</strong>，新数组中的元素是通过检查数组中符合条件的所有元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-keyword">var</span> result = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) &#123;<br>    <span class="hljs-keyword">return</span> number &gt; <span class="hljs-number">3</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><h2 id="数组转换成字符串方法join">数组转换成字符串方法join</h2><p><code>join()</code>可以将一个数组中的元素连接成一个字符串，参数是我们指定的一个字符作为连接符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>]<br><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">//aabb</span><br><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;@&quot;</span>)<span class="hljs-comment">//aa@bb</span><br></code></pre></td></tr></table></figure><h2 id="截取数组方法slice">截取数组方法slice()</h2><p>参数：截取的起始位置(包括)，截取的结束位置(不包括)</p><p>第二个参数可以省略，如果省略则一直截到最后</p><p>索引可以写负值</p><ul class="lvl-0"><li class="lvl-2"><p>如果两个参数全部省略，则可以对数组进行浅拷贝</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">arr = [<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Andy&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>]<br><br>result = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">//&quot;Tom&quot;,&quot;Andy&quot;</span><br></code></pre></td></tr></table></figure><h1>浅拷贝和深拷贝</h1><h2 id="浅拷贝">浅拷贝</h2><ul class="lvl-0"><li class="lvl-2"><p>通常对对象的拷贝都是浅拷贝</p></li><li class="lvl-2"><p>浅拷贝顾名思义，只对对象的浅层进行拷贝</p></li><li class="lvl-2"><p>如果对象中存储的数据是原始值，那么拷贝的深浅不重要</p></li><li class="lvl-2"><p>浅拷贝只会对对象本身进行复制，不会复制对象中的属性，或元素</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Tom&quot;</span>&#125;,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;bob&quot;</span>&#125;]<br><span class="hljs-keyword">const</span> arr2 = arr.<span class="hljs-title function_">slice</span>()<span class="hljs-comment">//浅拷贝</span><br></code></pre></td></tr></table></figure><h2 id="深拷贝">深拷贝</h2><ul class="lvl-0"><li class="lvl-2"><p>不仅复制对象本身，还复制对象中的属性和元素</p></li><li class="lvl-2"><p>通常情况下不使用深拷贝</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr3 = <span class="hljs-title function_">structuredClone</span>(arr)<span class="hljs-comment">//深拷贝</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中的面向对象编程</title>
    <link href="/2024/03/05/JavaScript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/03/05/JavaScript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1>类</h1><ol><li class="lvl-3">类是对象模版，可以将对象中的属性和方法直接定义在类中，定义后就可以直接通过类来创建对象</li><li class="lvl-3">通过同一个类创建的对象，我们称之为同对象，可以通过<code>instanceof</code>来检查一个对象是否是某个类创建，则我们称该对象是这个类的实例</li><li class="lvl-3">通过类创建对象的语法<code>new 类()</code></li></ol><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><span class="hljs-comment">//person类专门用来创建人的对象</span><br>&#123;<br><br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span> <span class="hljs-comment">//p1是person的实例</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="属性">属性</h2><p>类是创建对象的模板，要创建第一件事就是定义类</p><p>使用<code>static</code>声明的属性为静态属性，不可以通过实例访问，只能通过类访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    name = <span class="hljs-string">&#x27;Tom&#x27;</span><span class="hljs-comment">//Person的实例属性name</span><br>    age = <span class="hljs-number">18</span><span class="hljs-comment">//实例属性只能通过实例访问 p1.age</span><br>    <span class="hljs-keyword">static</span> test = <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-comment">//静态属性只能通过类访问 Person.test</span><br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br></code></pre></td></tr></table></figure><h2 id="构造函数">构造函数</h2><p>当我们在类中直接指定值的时候，意味着我们创建的所有对象都是这个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Perosn</span>&#123;<br>name = <span class="hljs-string">&quot;Tom&quot;</span><br>age = <span class="hljs-number">18</span><br>gender = <span class="hljs-string">&#x27;男&#x27;</span><br><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想自己给类的属性赋值怎么办？</p><p>此时我们可以使用一个特殊的方法——构造函数(constructor)</p><p>构造函数会在我们调用类创建对象时执行，我们可以在构造函数中为属性赋值，在构造函数中，this表示当前创建的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span><br>&#123;<br>    name<br>    age<br>    gender<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age,gender</span>)<br>    &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>封装</h1><ul class="lvl-0"><li class="lvl-2"><p>封装、继承、多态是面向对象编程三大特性</p></li></ul><p>对象就是一个用来存储不同属性的容器，对象不仅负责属性，还要负责数据的安全，直接添加到对象中的属性并不安全，因为他们可以被任意修改</p><p>如何保证数据安全？</p><ol><li class="lvl-3"><p>私有化数据</p><ul class="lvl-2"><li class="lvl-5">将需要保护的数据设置为私有，只能在类内使用，私有属性必须事先说明</li></ul></li><li class="lvl-3"><p>提供类内公有方法来间接读取类内私有属性，相当于提供一个接口，该方法的好处是不仅可以控制属性的读写权限还可以在方法中对属性值进行控制</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><br>#address = <span class="hljs-string">&#x27;Beijing&#x27;</span> <span class="hljs-comment">// 实例使用#开头就变成了私有属性 私有属性只能在类内部访问</span><br>#name;<br>#age;<br>#gender<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age,gender</span>)&#123;<br><span class="hljs-variable language_">this</span>.#name = name<br><span class="hljs-variable language_">this</span>.#age = age<br><span class="hljs-variable language_">this</span>.#gender = gender<br>&#125;<br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.#name)<br>&#125;<br><br><span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//getter方法，用来读取属性</span><br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name<br>&#125;<br><span class="hljs-title function_">setAge</span>(<span class="hljs-params">age</span>)&#123;<span class="hljs-comment">//setter方法，用来设置属性</span><br><span class="hljs-keyword">if</span>(age&gt;=<span class="hljs-number">0</span>)&#123;<br><span class="hljs-variable language_">this</span>.#age = age<br>&#125;<br>&#125;<br><span class="hljs-keyword">get</span> <span class="hljs-title function_">gender</span>()&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#gender<br>&#125;<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Perosn</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;男&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">gender</span>())<br><br></code></pre></td></tr></table></figure><h1>多态</h1><ul class="lvl-0"><li class="lvl-2"><p>在Js中不会检查参数的类型，这就意味着任何数据都可以作为参数传递</p></li><li class="lvl-2"><p>要调用某个函数，无需指定的类型，只要对象满足某些条件即可</p></li><li class="lvl-2"><p>多态为我们提供了灵活性</p></li></ul><h1>继承</h1><p>通过<code>extends</code>关键字来完成继承</p><p>简单来说，当一个类继承另一个类时，就相当于将另一个类复制到了代码中</p><p>在继承中，被继承的类称为<strong>父类</strong>，继承的类称为<strong>子类</strong></p><p>通过继承可以大大减少重复的代码，并且可以在不修改一个类的前提下对其进行扩展</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> 子类 <span class="hljs-keyword">extends</span> 父类<br></code></pre></td></tr></table></figure><p>在子类中，可以通过创建同名方法来重写父类的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;动物在叫&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span>&#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name ,age</span>)&#123;<br><span class="hljs-comment">//重新构造函数时，构造函数的第一行代码必须为super()</span><br><span class="hljs-variable language_">super</span>(name)<span class="hljs-comment">//this.name = name</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//调用父类的sayHello</span><br><span class="hljs-comment">// super.sayHello//动物在叫</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;喵喵喵&quot;</span>)<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;汤姆&quot;</span>,<span class="hljs-number">5</span>)<br><br>cat.<span class="hljs-title function_">sayHello</span>()<span class="hljs-comment">//喵喵喵</span><br></code></pre></td></tr></table></figure><p>注意，如果你想调用父类中的方法活着构造函数，你需要用<code>super()</code>来调用父类的属性</p><h1>对象的结构</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>name = <span class="hljs-string">&#x27;Tom&#x27;</span><br>age = <span class="hljs-number">18</span><br><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello,&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)<br></code></pre></td></tr></table></figure><p>如果你打印出这个对象，你会发现可以看见里面的name，age但是看不见sayHello方法</p><p>对象中存储属性的区域实际上有两个</p><ol><li class="lvl-3"><p>对象自身</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>直接通过对象添加的属性，位于对象自身中</p></li><li class="lvl-2"><p>在类中通过 x=y 添加的属性位于对象自身中</p></li></ul><ol start="2"><li class="lvl-3"><p>原型对象</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>在对象中还有一些内容会存储到其他的位置</p></li><li class="lvl-2"><p>在对象中会有一个属性来存储原型对象， 这个属性叫做<code>__proto__</code>，原型对象也负责为对象存储属性</p></li><li class="lvl-2"><p>当我们访问对象中的属性时，会优先访问对象自身的属性，如果找不到，则去原型对象中去找</p></li><li class="lvl-2"><p>会添加到原型对象中的情况</p><ol><li class="lvl-5">在类中通过xxx(){}方式添加的方法，位于原型对象中</li><li class="lvl-5">主动向原型中添加属性或方法</li></ol></li></ul><h1>原型对象</h1><p>原型对象中的数据结构：</p><ol><li class="lvl-3"><p>对象中的数据（属性，方法等）</p></li><li class="lvl-3"><p>constructor（对象的构造函数）</p></li></ol><h2 id="原型链">原型链</h2><p>原型对象也有原型，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同，原型链最后指向NULL</p><p>读取对象属性时，优先在对象本身中寻找，如果对象中有，则使用，没有则去对象的原型中找，如果原型中有，则使用，没有则去原型的原型中去寻找，直到找到Object对象的原型，Object的原型没有原型（null），如果依然没有找到，返回Undefined。</p><p>区分作用域链和原型链</p><ul class="lvl-0"><li class="lvl-2"><p>作用域链，找变量的链，找不到会报错</p></li><li class="lvl-2"><p>原型链，是找属性的链，找不到会返回Undefined</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>name = <span class="hljs-string">&#x27;Tom&#x27;</span><br>age = <span class="hljs-number">18</span><br><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello,&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)<span class="hljs-comment">//可以看见name 和 age 看不见方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span>)<span class="hljs-comment">//原型对象,不建议这么访问</span><br><br>concole.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(p))<span class="hljs-comment">//安全访问</span><br></code></pre></td></tr></table></figure><h2 id="原型的作用">原型的作用</h2><ul class="lvl-0"><li class="lvl-2"><p>所有的同类型对象，他们的原型对象是一个，也就意味着原型链也是一个</p></li><li class="lvl-2"><p>原型的作用</p><ul class="lvl-2"><li class="lvl-4">相当于一个公共的区域，可以被所有的类访问。</li><li class="lvl-4">可以将一个该类实例中所有的公共属性(方法)统一存储到原型中，这样我们只需要创建一个属性，即可被所有实例访问</li><li class="lvl-4">JS中继承就是通过原型实现的</li><li class="lvl-4">继承时，子类的原型就是一个父类的实例。</li><li class="lvl-4">在对象中有些属性是对象独有的，像属性，每个对象都应该有自己值，但是有些值对于每个对象来说都是一样的，像各种方法，对于一样的值没有必要重复的创建</li></ul><h2 id="修改原型">修改原型</h2><p>大部分情况下不需要修改原型</p><p><strong>注意！</strong></p><p>千万不要通过类的实例去修改原型！</p><ol><li class="lvl-5"><p>通过一个对象影响所有同类对象，这样不合适</p></li><li class="lvl-5"><p>修改原型需要先创建实例，繁琐</p></li><li class="lvl-5"><p>危险</p></li></ol></li><li class="lvl-2"><p>处理通过<code>__proto__</code>能访问对象的原型外，还可以通过类的prototype属性来访问实例的原型</p></li></ul><p>好处</p><ol><li class="lvl-3"><p>修改一个就是修改所有实例的原型</p></li><li class="lvl-3"><p>无需创建实例即可完成对类的修改</p></li></ol><p>原则</p><ol><li class="lvl-3"><p>尽量不要改</p></li><li class="lvl-3"><p>通过类.prototype来改</p></li><li class="lvl-3"><p>最好不要直接给prototype赋值</p></li></ol><h1>instanceof 和 hasOwn</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span>&#123;&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>)<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>)<span class="hljs-comment">//true`</span><br></code></pre></td></tr></table></figure><p><code>instanceof</code>用来检查一个对象是否是一个类的实例</p><ul class="lvl-0"><li class="lvl-2"><p>检查的是对象的原型链上是否有改类实例，只要有，返回true</p></li><li class="lvl-2"><p>dog -&gt; Animal的实例 -&gt; Object实例 -&gt; Object原型</p></li><li class="lvl-2"><p><code>Object</code>是所有对象的原型，所以任何对象和<code>Object</code>进行<code>instanceof</code>运算都会返回true</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>name = <span class="hljs-string">&#x27;Tom&#x27;</span><br>age = <span class="hljs-number">18</span><br><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name in p&quot;</span>)<span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;sayHello in p&quot;</span>)<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;sayHello&quot;</span>))<span class="hljs-comment">//flase</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(p,<span class="hljs-string">&quot;sayHello&quot;</span>))<span class="hljs-comment">//flase</span><br></code></pre></td></tr></table></figure><p>使用<code>in</code>运算符检查属性时，无论属性在对象自身还是在原型中，都返回true</p><ul class="lvl-0"><li class="lvl-2"><p><code>对象.hasOwnProperty(属性名)</code></p><ul class="lvl-2"><li class="lvl-6">用来检查一个对象自身是否含有某个属性</li></ul></li><li class="lvl-2"><p><code>Object.hasOwn(对象,&quot;属性名&quot;)</code></p><ul class="lvl-2"><li class="lvl-6">用来检查一个对象自身是否含有某个属性</li></ul></li></ul><h1>new 运算符</h1><ul class="lvl-0"><li class="lvl-2"><p>new运算符是创建对象时要用到的运算符</p></li></ul><p>使用new的时候发生呢干了什么？</p><p>当我们用new去调用一个函数，这个函数将会作为构造函数调用</p><ol><li class="lvl-3"><p>创建一个普通的JS对象（Object{ }），为了方便，称其为新对象</p></li><li class="lvl-3"><p>指定新对象的原型指定为构造函数的prototype的属性</p></li><li class="lvl-3"><p>使用实参来执行构造函数，并且将我们的新对象设置为函数中的this</p></li><li class="lvl-3"><p>如果构造函数返回的是一个非原始值，则该值会作为new运算的返回值返回，如果返回的是原始值或者没有返回值，则新的对象作为返回值（通常不要返回值）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中的对象</title>
    <link href="/2024/03/04/JavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/03/04/JavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1>对象基本操作</h1><ul class="lvl-0"><li class="lvl-2">如果我们需要在程序中表示一个人的信息，使用原始值无法表现出“一个整体的”的特点，对象能够完成这个任务</li><li class="lvl-2">对象是JS中的一个复合数据类型，它相当于一个容器，在对象中可以存储各种不同类型的数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span> <span class="hljs-comment">//创建了一个新的对象</span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span> <span class="hljs-comment">//简化版，省略了new</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2">对象中可以存储多个类型的数据，对象里存储的数据被称为属性</li><li class="lvl-2">向对象中添加属性：对象.属性名 = 属性值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Tom&quot;</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br>obj.<span class="hljs-property">gender</span> = <span class="hljs-string">&quot;男&quot;</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2">读取对象中的属性对象.属性名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>)<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2">修改对象中的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2">删除对象中的属性</li><li class="lvl-2">如果读取的是一个对象中没有的属性，会输出Undefined</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">delete</span> obj.<span class="hljs-property">name</span><br></code></pre></td></tr></table></figure><h1>对象的属性</h1><h2 id="属性名">属性名</h2><ul class="lvl-0"><li class="lvl-2"><p>通常属性名就是一个字符串，所以属性名可以是任何值，没有特殊要求，但是太特殊会不能直接使用，还是强烈建议属性名也按照标识符的规范</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">if</span> = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-comment">//合法</span><br>obj.<span class="hljs-property">let</span> = <span class="hljs-string">&#x27;666&#x27;</span> <span class="hljs-comment">//合法</span><br>obj<span class="hljs-number">.1234</span> = <span class="hljs-string">&#x27;2334&#x27;</span> <span class="hljs-comment">//不合法！</span><br>obj.[<span class="hljs-string">&quot; 123@**!! &quot;</span>] = <span class="hljs-string">&quot;123&quot;</span> <span class="hljs-comment">//合法</span><br><span class="hljs-comment">//避免使用这些属性名</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>也可以用符号作为属性名，使用symbol作为属性名</p></li><li class="lvl-2"><p>获取这种属性时也需要通过symbol获取</p></li><li class="lvl-2"><p>使用symbol获取的属性，通常是不希望被外界访问的属性</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> mySymbol = <span class="hljs-title class_">Symbol</span>()<br>obj[symbol] = <span class="hljs-string">&quot;通过symbol添加的属性&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[mySymbol])<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>使用[]操作属性时，可以使用变量</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;address&#x27;</span><br>obj[str] = <span class="hljs-string">&#x27;翻斗大街&#x27;</span><span class="hljs-comment">//等价于obj[&quot;address&quot;] = &#x27;翻斗大街&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="属性值">属性值</h2><ul class="lvl-0"><li class="lvl-2"><p>对象的属性值可以是任意的数据类型，也可以是<strong>一个对象</strong></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">f</span> = <span class="hljs-title class_">Object</span>()<br>obj.<span class="hljs-property">f</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Bob&#x27;</span><br>obj.<span class="hljs-property">f</span>.<span class="hljs-property">age</span> = <span class="hljs-number">28</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">f</span>.<span class="hljs-property">name</span>)<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>in</code>运算符</p></li><li class="lvl-2"><p>检查对象是否有某个属性，返回true或false</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name&quot;</span><span class="hljs-keyword">in</span> obj)<br></code></pre></td></tr></table></figure><h1>对象字面量</h1><p>可以使用字面量的方式创建对象可以直接使用{}来创建对象可以直接向对象里添加属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,[<span class="hljs-string">&quot;gender&quot;</span>]:<span class="hljs-string">&#x27;男&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h1>枚举对象中的属性</h1><ul class="lvl-0"><li class="lvl-2"><p>枚举属性：将对象中的所有的属性全部获取</p></li><li class="lvl-2"><p><code>for-in</code>语句</p></li><li class="lvl-2"><p><code>for(let propName in 对象)&#123;...&#125;</code></p></li><li class="lvl-2"><p>有几个属性运行几次，并不是所有的属性都可以枚举，比如用符号添加的属性</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj =&#123;<br>name=<span class="hljs-string">&#x27;Tom&#x27;</span>,<br>age = <span class="hljs-number">18</span>,<br>gender = <span class="hljs-string">&#x27;男&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> propName <span class="hljs-keyword">in</span> obj)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//打印三次</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(propName, obj[propName])<span class="hljs-comment">//获取属性名以及属性值</span><br>&#125;<br></code></pre></td></tr></table></figure><h1>可变类型</h1><ul class="lvl-0"><li class="lvl-2"><p>原始值都属于不可变类型，一旦创建就无法修改，在内存中不会创建重复的原始值</p></li><li class="lvl-2"><p>对象是一种可变类型，对象创建完成后，可以任意的添加修改删除对象中的属性</p></li><li class="lvl-2"><p><strong>注意</strong>：如果有两个变量同时指向一个对象，同一个变量修改对象时也会产生影响</p></li><li class="lvl-2"><p>当两个对象进行比较时，实际比较的是内存地址</p></li></ul><h1>变量和对象</h1><ul class="lvl-0"><li class="lvl-2"><p>修改对象</p></li></ul><p>修改对象时，如果有其他变量指向该对象，则所有指向改对象的变量都会受到影响</p><ul class="lvl-0"><li class="lvl-2"><p>修改变量</p></li></ul><p>修改变量时，只会影响当前的变量</p><ul class="lvl-0"><li class="lvl-2"><p>在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度，所以通常情况下，声明存储对象的变量时会使用const</p></li></ul><h1>方法</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br><br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Tom&#x27;</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br><span class="hljs-comment">//函数也可以称为一个对象的属性</span><br>obj.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello!&#x27;</span>)<br>&#125;<br>obj.<span class="hljs-title function_">sayHello</span>()<span class="hljs-comment">//调用obj的sayHello方法</span><br></code></pre></td></tr></table></figure><p>方法</p><ul class="lvl-0"><li class="lvl-2"><p>放一个对象的属性指向一个函数，那么我们就称这个函数是该对象的方法，调用函数就被称为调节对象的方法。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript函数基础</title>
    <link href="/2024/03/04/JavaScript%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/04/JavaScript%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1>定义函数</h1><h2 id="函数声明">函数声明</h2><p>一个函数定义（也称为函数声明，或者函数语句）由<code>function</code>关键字，并跟随以下部分组成</p><ul class="lvl-0"><li class="lvl-2">函数名称</li><li class="lvl-2">函数参数列表</li><li class="lvl-2">定义函数的JavaScript语句</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">number</span>)&#123;<br>    <span class="hljs-keyword">return</span> number + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>typeof</code>检测类型为function</p></li></ul><p>参数本质上是按照值传递给函数的——因此即使函数体的代码为传递函数的参数赋了新值，这个改变也不会反映到全局或调用该函数的代码中。</p><p>如果你将对象作为参数传递，而参数改变了这个对象的属性，这样的改变对函数外部是可见的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">theObject</span>) &#123;<br>  theObject.<span class="hljs-property">make</span> = <span class="hljs-string">&quot;Toyota&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> mycar = &#123;<br>  <span class="hljs-attr">make</span>: <span class="hljs-string">&quot;Honda&quot;</span>,<br>  <span class="hljs-attr">model</span>: <span class="hljs-string">&quot;Accord&quot;</span>,<br>  <span class="hljs-attr">year</span>: <span class="hljs-number">1998</span>,<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mycar.<span class="hljs-property">make</span>); <span class="hljs-comment">// &quot;Honda&quot;</span><br><span class="hljs-title function_">myFunc</span>(mycar);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mycar.<span class="hljs-property">make</span>); <span class="hljs-comment">// &quot;Toyota&quot;</span><br><br></code></pre></td></tr></table></figure><p>如果你将数组作为参数传递，而参数改变了这个数组的值，这样的改变对函数外部也同样可见</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">theArr</span>) &#123;<br>  theArr[<span class="hljs-number">0</span>] = <span class="hljs-number">30</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">45</span>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 45</span><br><span class="hljs-title function_">myFunc</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 30</span><br><br></code></pre></td></tr></table></figure><h2 id="函数表达式">函数表达式</h2><p>由函数表达式创建的函数是<strong>匿名</strong>的，它不必有一个名称,例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> square = <span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>)&#123;<br>    <span class="hljs-keyword">return</span> number*number;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以为函数表达式提供名称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> factorial = <span class="hljs-keyword">function</span> <span class="hljs-title function_">fac</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : n * <span class="hljs-title function_">fac</span>(n - <span class="hljs-number">1</span>);<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>我们也可以将函数作为函数的参数,函数也是对象的一种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params">a</span>)&#123;<br><span class="hljs-title function_">a</span>()<br>&#125;<br><br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是fn2&quot;</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>(fn2)<span class="hljs-comment">//我是fn2</span><br></code></pre></td></tr></table></figure><h1>函数参数</h1><ul class="lvl-0"><li class="lvl-2"><p>在定义函数中，可以在函数中指定数量不等的参数</p></li><li class="lvl-2"><p>在函数中定义形参相当于在函数内部生成了一个没有赋值的变量</p></li><li class="lvl-2"><p>在调用函数时候，可以在函数的()内传递数量不等的实参</p></li><li class="lvl-2"><p>实参会赋值给对应的形参</p></li><li class="lvl-2"><p>参数</p><ol><li class="lvl-5">如果实参和形参数量相同，则对应的实参复制给对应的形参</li><li class="lvl-5">如果实参多于形参，则多余的实参不会使用</li><li class="lvl-5">如果形参多于实参 ，则多余的形参为Undefined</li></ol></li><li class="lvl-2"><p>任何值都可以作为参数，<strong>注意：函数不会检查类型</strong></p></li></ul><h2 id="函数重载">函数重载</h2><ul class="lvl-0"><li class="lvl-2"><p>函数通过参数的个数和类型不同来创建不同的函数签名，通过调用函数时传入的参数个数和参数类型来进行命名参数的验证。</p></li><li class="lvl-2"><p>但是，在js后声明的同名函数会对前面声明的一个函数进行一个覆盖，所以JavaScript没有真正意义上的函数重载</p></li></ul><h2 id="类数组arguments对象">类数组arguments对象</h2><ul class="lvl-0"><li class="lvl-2"><p>如果一个函数传递了三个参数，你可以以如下方式引用他们</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]<br><span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]<br><span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h2 id="回调函数">回调函数</h2><pre><code class="hljs">回调函数是一个函数，将会在另一个函数完成执行后立即执行。回调函数是一个作为参数传给另一个 JavaScript 函数的函数。这个回调函数会在传给的函数内部执行。</code></pre><h1>函数提升</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-comment">//Undefined</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="变量的提升">变量的提升</h2><ul class="lvl-0"><li class="lvl-2"><p>使用var声明的变量，它会在所有代码执行前被声明但是<strong>不会被赋值</strong></p><ul class="lvl-2"><li class="lvl-4">我们可以在变量声明前就访问变量</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fn</span>()<span class="hljs-comment">//可以成功执行</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;111&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数的提升">函数的提升</h2><ul class="lvl-0"><li class="lvl-2"><p>使用**函数声明（function开头）**创建的函数，会在其他代码执行前被创建</p></li><li class="lvl-2"><p>我们可以在函数声明前调用函数</p></li><li class="lvl-2"><p>JavaScript解释器会将整个函数声明提升到当前作用域的顶部</p></li></ul><h2 id="let声明的变量">let声明的变量</h2><ul class="lvl-0"><li class="lvl-2"><p>let声明的变量实际上也会提升，但是在赋值之前解释器禁止访问该变量</p></li></ul><h1>函数作用域</h1><p>在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的作用域内定义。相对应的，一个函数可以访问定义在其范围内的任何变量和函数</p><ul class="lvl-0"><li class="lvl-2"><p>函数作用域在函数调用时产生，调用结束后销毁</p></li><li class="lvl-2"><p>函数每次调用都会产生一个全新的函数作用域</p></li><li class="lvl-2"><p>在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问</p></li></ul><h1>闭包</h1><p>闭包是 JavaScript 中最强大的特性之一。JavaScript 允许函数嵌套，并且内部函数具有定义在外部函数中的所有变量和函数（以及外部函数能访问的所有变量和函数）的完全访问权限。</p><p>但是，外部函数却不能访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一种封装。</p><p>此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数的生存周期将比内部函数执行的持续时间要长。当内部函数以某一种方式被任何一个外部函数之外的任何作用域访问时，就会创建闭包</p><p><strong>注意：使用闭包时需要注意许多陷阱！</strong></p><p>如果一个闭包的函数定义了一个和外部的某个变量名称相同的变量，那么这个闭包将无法引用外部作用域中的这个变量。（内部作用域的变量“覆盖”外部作用域，直至程序退出内部作用域。可以将其视作命名冲突。</p><h1>作用域链</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span><br>&#123;<br><span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;第一代码块中的a&quot;</span><br>&#123;<br><span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;第二代码块中的a&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-comment">//第二代码块中的a</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用域链</p><ul class="lvl-0"><li class="lvl-4"><p>当我们使用一个变量时，JavaScript解释器会优先在当前作用域中寻找变量，如果找到了则直接使用，如果没找到，则去上一层作用域中寻找，如果一直没找到，就会报错！</p></li></ul><h1>window对象</h1><ul class="lvl-0"><li class="lvl-2"><p>浏览器为我们提供了一个window对象，可以直接访问</p></li><li class="lvl-2"><p>window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作，除此之外，window对象还负责存储JS中的内置对象和浏览器的宿主对象</p></li><li class="lvl-2"><p>window对象的属性可以通过window对象访问，也可以直接访问</p></li><li class="lvl-2"><p>函数可以认为是window对象的方法</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-number">123</span>)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">console</span>.<span class="hljs-title function_">log</span>()<span class="hljs-comment">//window可省略</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span> = <span class="hljs-number">10</span><span class="hljs-comment">//向window中添加的属性会自动成为全局变量</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>var用来声明变量，作用和let相同，但是var不具有块作用域</p><ul class="lvl-2"><li class="lvl-4">全局中使用var声明的变量，都会作为window对象的属性保存</li><li class="lvl-4">使用function声明的函数，都会作为window的方法保存</li><li class="lvl-4">使用let声明的变量不会存储在window<br>综合例子：</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-number">20</span> <span class="hljs-comment">//window.b = 20</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是fn&#x27;</span>)<br>&#125;<br><br><span class="hljs-title function_">fn</span>()<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">fn</span>()<br><br><span class="hljs-keyword">let</span> c = <span class="hljs-number">33</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">c</span>()<span class="hljs-comment">//Undefined</span><br><br><span class="hljs-keyword">let</span> c = <span class="hljs-number">33</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">c</span> = <span class="hljs-number">44</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c)<span class="hljs-comment">//33 首先在秘密的地方找</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//var d = 10 var虽然没有块作用域，但是有函数作用域</span><br>d = <span class="hljs-number">10</span><span class="hljs-comment">//在局部作用域中，如果没有使用var或者let声明变量，则变量自动称为window对象的属性也就是全局变量，不要这样！！</span><br>&#125;<br><br><span class="hljs-title function_">fn2</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d)<span class="hljs-comment">//可以访问</span><br></code></pre></td></tr></table></figure><h1>函数中的this</h1><ul class="lvl-0"><li class="lvl-2"><p>环境对象this</p></li><li class="lvl-2"><p>函数在执行时，JavaScript解释器每次都会传递一个隐含的参数，这个参数叫this</p></li><li class="lvl-2"><p>this会指向一个对象</p><ul class="lvl-2"><li class="lvl-4">this指向的对象会根据函数调用方式的不同而不同<ol><li class="lvl-7">以函数形式调用，this指向<code>window</code></li><li class="lvl-7">以方法的方式调用，this指向的是调用方法的对象</li><li class="lvl-7">谁调用指向谁例子：</li></ol></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<span class="hljs-comment">//this === window</span><br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span>&#125;<br><br>obj.<span class="hljs-property">test</span> = fn<br><br><span class="hljs-keyword">const</span> obj2 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Bob&#x27;</span>,<span class="hljs-attr">test</span>:fn&#125;<br><br><span class="hljs-title function_">fn</span>()<span class="hljs-comment">//window window.fn()</span><br>obj.<span class="hljs-title function_">test</span>()<span class="hljs-comment">//name:&#x27;Tom&#x27;</span><br>obj2.<span class="hljs-title function_">test</span>()<span class="hljs-comment">//name:&#x27;Bob&#x27;,test:fn</span><br></code></pre></td></tr></table></figure><h1>箭头函数</h1><p>箭头函数表达式相比函数表达式有着更简洁的语法。箭头函数总是匿名的</p><p>有两个因素会影响箭头函数的引入：更简洁的函数和<code>this</code>的无绑定性</p><p>定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> 变量 = <span class="hljs-function">() =&gt;</span>&#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">const</span> 变量 = <span class="hljs-function">() =&gt;</span> ...<br></code></pre></td></tr></table></figure><h2 id="箭头函数参数和返回值">箭头函数参数和返回值</h2><p>箭头函数只有一个参数时，可以省略括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn2</span> = a =&gt;&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数的返回值可以写在箭头后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> a+b<br>&#125;<br>简化为<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a,b</span>) =&gt; a+b<br></code></pre></td></tr></table></figure><p>如果直接在箭头后设置对象字面量为返回值时，对象字面量必须使用（）括起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; (&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;TOM&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h2 id="箭头函数的this">箭头函数的this</h2><ul class="lvl-0"><li class="lvl-2"><p>箭头函数没有自己的this，它的this由外层作用域决定，和他的this无关举例说明：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fn --&gt;&quot;</span>,<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn2</span> = (<span class="hljs-params"></span>) =&gt; (<span class="hljs-string">&quot;fn2 --&gt;&quot;</span>,<span class="hljs-variable language_">this</span>)<br><br><span class="hljs-title function_">fn</span>()<span class="hljs-comment">//--&gt;window</span><br><span class="hljs-title function_">fn2</span>()<span class="hljs-comment">//--window</span><br><br><span class="hljs-keyword">const</span> obj=&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span>,<br><span class="hljs-attr">fn</span>:fn,<br>fn2,<span class="hljs-comment">//属性名和属性值相同可以省略</span><br>sayHello<span class="hljs-comment">/*:function(可以省略)*/</span>()&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">t</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;t--&gt;&quot;</span>,<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-title function_">t</span>()<span class="hljs-comment">//--&gt;window 由函数调用</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">t2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;t2 --&gt;&quot;</span>,<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-title function_">t2</span>()<span class="hljs-comment">//--&gt;obj 箭头函数this由外层作用域决定</span><br>&#125;<br>&#125;<br>obj.<span class="hljs-title function_">fn</span>()<span class="hljs-comment">//--&gt;obj</span><br>obj.<span class="hljs-title function_">fn2</span>()<span class="hljs-comment">//--&gt;window</span><br></code></pre></td></tr></table></figure><h1>立即执行函数</h1><p>在开发中应该尽量减少直接在全局作用域中编写代码！</p><p>我们的代码要尽量编写在局部作用域中，如果使用let声明的变量，可以利用{}来创建块作用域</p><p>立即执行函数是一个匿名的函数，并且只会调用一次</p><p>可以利用立即执行函数来创建一个一次性的函数作用域，避免变量冲突</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span><br>&#125;() );<span class="hljs-comment">//两个在一起要加分号</span><br><br>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span><br>&#125;() )<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础</title>
    <link href="/2024/03/03/JavaScript%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/03/JavaScript%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1>Javascript简介</h1><ul class="lvl-0"><li class="lvl-2">JavaScript 是一门跨平台、面向对象的脚本语言，它能使网页可交互（例如拥有复杂的动画，可点击的按钮，通俗的菜单等）。另外还有高级的服务端 Javascript 版本，例如 Node.js，它可以让你在网页上添加更多功能，不仅仅是下载文件（例如在多台电脑之间的协同合作）。在宿主环境（例如 web 浏览器）中，JavaScript 能够通过其所连接的环境提供的编程接口进行控制</li><li class="lvl-2">JavaScript是一种动态弱类型语言</li><li class="lvl-2">如今，JavaScript 已经成为了与 HTML/CSS 完全集成的，使用最广泛的浏览器语言</li></ul><h1>变量</h1><p>我们可以用 var ，let 或 const 声明变量来存储数据</p><ul class="lvl-0"><li class="lvl-2"><p>let - 现代的变量声明方式</p></li><li class="lvl-2"><p>var - 老旧的变量声明方式，一般情况下，我们不会再使用它。</p></li><li class="lvl-2"><p>const - 类似于let，但是变量的值无法被修改</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> a;<br><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h1>JavaScript标识符</h1><p>所有JavaScript变量必须以<strong>唯一</strong>的名称为标识</p><p>这些唯一的名称称为<strong>标识符</strong></p><p>构造变量名称的通用规则是：</p><ol><li class="lvl-3"><p>名称可以包含字母，数字，下划线，和美元符号$</p></li><li class="lvl-3"><p>名称也可以以字母，$ 和 _ 开头</p></li><li class="lvl-3"><p>名称对大小写敏感（y和Y是两个变量）</p></li><li class="lvl-3"><p>保留字无法用做变量名称</p></li></ol><h1>数据类型</h1><p>JavaScript 有八种基本的数据类型（七种基本数据类型和一个复杂数据类型）</p><ul class="lvl-0"><li class="lvl-2"><p>Number</p><ul class="lvl-2"><li class="lvl-6">用于任何类型的数字：整数或浮点数，范围在±（253-1）范围内的整数</li></ul></li><li class="lvl-2"><p>BigInt</p><ul class="lvl-2"><li class="lvl-4">用于任意长度的整数</li></ul></li><li class="lvl-2"><p>String</p><ul class="lvl-2"><li class="lvl-4">用于字符串，一个字符串可以包含0个或多个字符类型</li></ul></li><li class="lvl-2"><p>Boolean</p><ul class="lvl-2"><li class="lvl-4">用于true 和 false</li><li class="lvl-4">true不一定等于1，false不一定等于0</li></ul></li><li class="lvl-2"><p>Null</p><ul class="lvl-2"><li class="lvl-4">表示未知值，只有一个null值的独立类型</li><li class="lvl-4">null表示空对象指针</li></ul></li><li class="lvl-2"><p>Undefined</p><ul class="lvl-2"><li class="lvl-4">用于还没有定义的值——只有一个undefined值的独立类型</li><li class="lvl-4">在使用var声明变量但是没有初始化时，这个变量就是undefined</li></ul></li><li class="lvl-2"><p>Symbol</p><ul class="lvl-2"><li class="lvl-4">用于唯一的标识符</li></ul></li><li class="lvl-2"><p>Object</p><ul class="lvl-2"><li class="lvl-4">用于更复杂的数据结构，比如function、array、date</li></ul></li></ul><p><strong>我们可以使用typeof运算符查看数据类型</strong></p><p><code>typeof x</code>或者<code>typeof(x)</code></p><ul class="lvl-0"><li class="lvl-2"><p>会返回字符串类型，例如“string”<br><code>typeof null</code>会返回“object”——这是js的错误，实际上它不是object</p></li></ul><h1>值的比较</h1><ul class="lvl-0"><li class="lvl-2"><p>运算符</p></li></ul><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:center">比较两个操作数的值是否相等</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">比较两个操作数的值是否不相等</td></tr><tr><td style="text-align:center">===</td><td style="text-align:center">比较两个操作数的值是否相等，同时检查类型是否相同</td></tr><tr><td style="text-align:center">!==</td><td style="text-align:center">比较两个操作数的值是否不相等，同时检查类型是否不相同</td></tr></tbody></table><p><strong>能不用<mark>就不用</mark>，尽量使用===来确保不会出现不可预料的错误</strong></p><h1>类型转换</h1><ol><li class="lvl-3"><p>显式类型转换</p><ol><li class="lvl-6">将其他数据类型转换成String类型<ul class="lvl-4"><li class="lvl-10"><p>toString()</p><p>该方法不会影响原来变量，它会将转换的结构返回。注意<strong>Null和Undefined没有toString方法</strong>，如果调用会报错</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<br>a = a.<span class="hljs-title function_">toString</span>();<br></code></pre></td></tr></table></figure><ul class="lvl-6"><li class="lvl-14"><p>String()<br>将被转换的数据作为参数传递给函数。使用String函数做类型强制转换时，对于Number和Boolean就是调用toString()方法，对于null和undefined，就不会调用toString()方法，它会将null直接转换成”null”，将undefined转换成”undefined”。</p></li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<br>a = <span class="hljs-title class_">String</span>(a);<br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-7">将其他的数据类型转换为Number类型<ul class="lvl-4"><li class="lvl-10">Number()<ol><li class="lvl-15">如果是纯数字的字符串，则直接将其转换为数字。</li><li class="lvl-15">如果字符串中有非自数字的内容，则转换为NaN。</li><li class="lvl-15">布尔类型转换成数字，true转成1，false转成0。</li><li class="lvl-15">Null转成数字0。</li><li class="lvl-15">Undefined转成数字NaN。</li></ol></li><li class="lvl-10">parseInt(),parseFloat()<ol><li class="lvl-15">parseInt()把一个字符串转换为一个整数，只取整数部分</li><li class="lvl-15">parseFloat()把一个字符串转换为一个浮点数，可获得有效消暑；</li><li class="lvl-15">对非String使用parseInt()或parseFloat()，它会将其转换为String。</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;123abc&#x27;</span>,<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&#x27;12.34.56ab&#x27;</span>;<br>a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-comment">//a:123</span><br>b = <span class="hljs-built_in">parseFloat</span>(b);<span class="hljs-comment">//b:12.34</span><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-7">将其他的数据类型转换为Boolean类型<ul class="lvl-4"><li class="lvl-10">Boolean()<br>1. 对于数字，0和NaN是false，其余的都是true。<br>2. 对于字符串，空串是false，其余的都是true。<br>3. 对于null和undefined，都是false。<br>4. 对于对象，都是true。</li></ul></li></ol></li><li class="lvl-3"><p>隐式类型转换</p><ol><li class="lvl-6">转换为String类型<ul class="lvl-4"><li class="lvl-10">为任意的数据加一个空串</li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<br>a = a + <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-comment">//a: &quot;123&quot;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-7">转换为Number类型<ul class="lvl-4"><li class="lvl-10">在数据前面加一个+</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;123&#x27;</span><br>a = +a <span class="hljs-comment">//a:123</span><br></code></pre></td></tr></table></figure></li><li class="lvl-7">转换为Boolean类型<ul class="lvl-4"><li class="lvl-9">为任意的数据取两次反</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>a = !!a <span class="hljs-comment">//a:true</span><br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础知识</title>
    <link href="/2024/03/02/CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/03/02/CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1>CSS基础</h1><p>CSS可以控制如内容的字体、颜色、大小和间距这些。一条CSS的样式定义包括属性和属性值，他们共同决定网页的外观</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* p 选择符用来选择页面中的所有 &lt;p&gt; 标签 */</span><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-comment">/* color 属性用来定义文本颜色，这里为黄色 */</span><br>    <span class="hljs-attribute">color</span>: yellow; <br>    <span class="hljs-comment">/* background-color 属性用来定义元素的背景色，这里为黑色 */</span><br>    <span class="hljs-attribute">background-color</span>: black；<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CSS基础语法">CSS基础语法</h2><h3 id="基本语法">基本语法</h3><p>由选择器指定CSS作用的对象，在一对大括号{ }内写一条或多条生命，声明由属性和属性值构成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">selector &#123;<br>    declaration1：value1;<br>    declaration2：value2;<br>    ...<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="CSS选择器的概念">CSS选择器的概念</h2><p>CSS选择器，是元素和其他部分组合起来告诉浏览器哪个HTML元素应当是被选为应用规则中的CSS属性值的方式。</p><ol><li class="lvl-3"><p>通配选择器，由一个星号<code>*</code>代指它选中了文章的所有内容</p></li><li class="lvl-3"><p>类型选择器，也叫标签名选择器或者是元素选择器，它在文档中选择了一个HTML标签/元素</p></li><li class="lvl-3"><p>类选择器，以一个句点<code>.</code>开头，会选择文档中应用了这个类的所有元素。</p></li><li class="lvl-3"><p>id选择器，开头为<code>#</code>而非句点，不过基本上和类选择器是同种用法。一个ID一般用到一次，虽然用多次也能正常显示，但是通过Javascript通过id控制元素就会发生错误。</p></li></ol><img src="/2024/03/02/CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.png" class="" title="这是图片的说明"><p>层叠是CSS的一个基本特征，意为多个选择符之间具有特定的优先级，它是一个定义了如何合并来自多个源的属性值的算法。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>段落最后颜色是蓝色，因为后面的样式会覆盖前面的样式</p><p>这是在同样优先级的情况下，如果在优先级不同的情况下呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.special</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;    <br>&#125;<br><br><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p>类选择器比元素选择器的优先级高，这次段落颜色将会变红，即使它是前面的样式。</p><p>所以，在同优先级的情况下，后定义的生效，不同级则优先级高的生效。各优先级关系，一般来说，选择器的优先级，范围越小，优先级越高。</p><p>id选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配符选择器</p><img src="/2024/03/02/CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.png" class="" title="这是图片的说明"><h2 id="CSS基本样式">CSS基本样式</h2><p>常用样式：</p><ol><li class="lvl-3"><p><code>font-size: 字体大小 px</code></p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-weight</span>: normal; //字体粗细<br><span class="hljs-attribute">font-style</span>: italic; //字体倾斜<br></code></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p><code>text-align: center</code>文本对齐</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-decoration</span>: none; //无装饰<br><span class="hljs-attribute">text-decoration</span>: overline; //上划线<br><span class="hljs-attribute">text-decoration</span>: line-through; //中划线<br><span class="hljs-attribute">text-decoration</span>: underline; //下划线<br><span class="hljs-attribute">text-transform</span>: uppercase; //文本转换，全部换为大写字母<br><span class="hljs-attribute">text-indent</span>: <span class="hljs-number">50px</span>; //首行缩进<br><span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">3px</span>; //字母间距<br><span class="hljs-attribute">word-spacing</span>: <span class="hljs-number">10px</span>; //单词间距<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">0.8</span>; //行间距<br><span class="hljs-attribute">white-space</span>: nowrap; //禁用<span class="hljs-selector-tag">html</span>框中文字编辑时的换行符（不必懂）<br><span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> red; //分别是文本的水平、垂直阴影以及阴影的模糊效果、阴影颜色<br></code></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p><code>color: 字体颜色</code></p></li><li class="lvl-3"><p><code>background: 背景样式</code></p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-color</span>: blue;   //颜色名称方式<br><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); //RGB方式<br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;     //十六进制方式<br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;bg.png&quot;</span>)  ; //设置背景图片<br><span class="hljs-attribute">background-size</span>: contain/cover; // 图片相对于盒子的尺寸<br><span class="hljs-attribute">background-repeat</span>: repeat-x;   //沿x方向阵列<br><span class="hljs-attribute">background-position</span>: right top; //设置背景图片初始位置<br><span class="hljs-attribute">background-attachment</span>: fixed;  //背景图片是否随网页滑动<br><span class="hljs-attribute">background</span>: <span class="hljs-number">#ffffff</span> <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;tree.png&quot;</span>) no-repeat right top;//简写形式<br></code></pre></td></tr></table></figure><ol start="5"><li class="lvl-3"><p><code>height</code>,<code>weight</code>,<code>margin</code>,<code>padding</code>,<code>border</code></p></li></ol><img src="/2024/03/02/CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.png" class="" title="这是图片的说明"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">border-style</span>: solid; // 边框样式<br>  <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#ccc</span>; // 边框颜色<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">15px</span>; // 边框宽度<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>; // 允许你设置元素的外边框圆角,该属性是将这四个属性 <span class="hljs-attribute">border-top-left-radius</span>、<span class="hljs-attribute">border-top-right-radius</span>、<span class="hljs-attribute">border-bottom-right-radius</span>，和 <span class="hljs-attribute">border-bottom-left-radius</span> 简写为一个属性。<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">15px</span> solid green; //边框粗细  实线  颜色 ，dotted是点线，double是双线，dashed是虚线<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;<br>&#125;<br>//<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;  设置内容的高度<br>//<span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;  设置内容的宽度<br></code></pre></td></tr></table></figure><ol start="6"><li class="lvl-3"><p><code>outline-style: 轮廓样式</code></p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">outline-color</span>: red;  //轮廓颜色<br><span class="hljs-attribute">outline-style</span>: dotted;  //轮廓样式<br><span class="hljs-attribute">outline-width</span>: thin;  轮廓宽度<br><span class="hljs-attribute">outline</span>: <span class="hljs-number">5px</span> solid yellow;   简写轮廓属性<br><span class="hljs-attribute">outline-offset</span>: <span class="hljs-number">25px</span>;//轮廓偏移<br></code></pre></td></tr></table></figure><p>轮廓（outline）和边框（border）的区别：</p><ol><li class="lvl-4"><p>border可应用于几乎所有有形的html元素，而outline是针对链接、表单控件等元素设计</p></li><li class="lvl-4"><p>outline的效果将随元素的focus而自动出现（除非手动设置outline-style），相应的由blur而自动消失。这些都是浏览器的默认行为，无需Javascript配合CSS来控制</p></li><li class="lvl-4"><p>outline是不占空间的，不会像border那样影响元素的尺寸或位置，也不会增加额外的width或者height</p></li><li class="lvl-4"><p>对于input之类的表单控件，当你手动设置outline-style，它将不会采用默认的触发方式，而是直接显示，在没有手动设置outline-style的情况下，outline-width不生效。</p></li><li class="lvl-3"><p><code>cursor: pointer;</code> 鼠标呈现为指示链接的一只手</p></li></ol><h2 id="CSS伪元素和伪类">CSS伪元素和伪类</h2><p><strong>什么是伪类？</strong></p><p>伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。</p><p><strong>语法</strong></p><p>伪类就是开头为冒号的关键字：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">selector: pseudo-class-name&#123;&#125;<br></code></pre></td></tr></table></figure><p>常见伪类：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-comment">/* 在用户将指针挪到元素上的时候才会激活 */</span><br><span class="hljs-selector-pseudo">:focus</span> <span class="hljs-comment">/* 获得焦点的元素激活 */</span><br></code></pre></td></tr></table></figure><p><strong>什么是伪元素？</strong></p><p>伪元素是一个附加到选择器末的关键词，允许你对被选择元素的特定部分修改样式。</p><p><strong>语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">selector::pseudo-element &#123;<br>  property: value;<br>&#125;<br></code></pre></td></tr></table></figure><p>常见伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">::after</span> <span class="hljs-comment">/* 用来创建一个伪元素，作为已选中元素的最后一个子元素,通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素 */</span><br><span class="hljs-selector-pseudo">::before</span> <span class="hljs-comment">/* 用来创建一个伪元素，作为已选中元素的第一个子元素，其余同上 */</span><br><span class="hljs-attribute">content</span> <span class="hljs-comment">/* 用于在元素的 ::before 和 ::after 伪元素中插入内容 */</span><br></code></pre></td></tr></table></figure><h2 id="HTMl和CSS的结合方式">HTMl和CSS的结合方式</h2><ol><li class="lvl-3"><p>行内式：html中的属性标签style：适用于单纯只有一个标签需要设置时的特殊样式。如果多个标签需要应用同一个样式，建议采用内嵌式。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue;background-color: yellow;border: 1px solid black;&quot;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>内嵌式：建议在head中使用，使用标签 style 适用于当前页面多个标签使用同一个样式。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">p</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: blue;</span><br><span class="language-css">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>内嵌<span class="hljs-tag">&lt;<span class="hljs-name">p</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>/&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>外链式：link:适用于多个页面使用同一个样式时。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/my.css&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>注意：link中href属性必须有，表示链接的css文件。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的HTML知识</title>
    <link href="/2024/03/01/%E5%B8%B8%E7%94%A8%E7%9A%84HTML%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/03/01/%E5%B8%B8%E7%94%A8%E7%9A%84HTML%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1>HTML是什么？</h1><p>超文本标记语言(英语:HyperText Markup Language,简称:HTML)是一种用于创建网页的标准标记语言。HTML是一种基础技术,常与CSS、JavaScript一起被众多网站用于设计网页、网页应用程序以及移动动应用程序的用户界面。网页浏览器可以读取HTML文件,并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的的呈现,使之成为一种标记语言而非编程语言。</p><h1>常用的HTML语法概述</h1><ol><li class="lvl-3"><p>HTML标签是由<strong>尖括号</strong>包围的关键词，例如 &lt;html&gt;</p></li><li class="lvl-3"><p>HTML标签通常是成对出现的，例如 &lt;html&gt;和/</html>，称为双标签。</p></li><li class="lvl-3"><p>有些特殊的标签必须是单个标签，例如&lt;br /&gt;，称为单标签。</p></li><li class="lvl-3"><p>双标签关系可以分为两类：包含关系（父子关系）和并列关系（兄弟关系）</p></li></ol><h2 id="HTML骨架代码">HTML骨架代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 不算是一个html标签，是文档规范，让浏览器能够正确地渲染页面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 根元素，lang表示文档语言类型为英文 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 向浏览器传递网页的基本信息和配置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 告诉浏览器使用utf-8编码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 确保在移动设备上正确显示和缩放网页内容 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 页面选项卡中的标题 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 页面呈现区域 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li class="lvl-3"><p>head:包含一些与文档相关的元数据和其他重要的信息，内容不会在浏览器中显示。</p><ol><li class="lvl-6"><code>title</code>：定义文档的标题，不同的页面类型有不同的格式。比如：主页，一般是网页名称+主要关键词。详情页，一般是详情名称+网站名字+简介等等。</li><li class="lvl-6"><code>link</code>：指定当前文档和外部资源的关系</li><li class="lvl-6"><code>meta</code>：设置网页的元数据，例如字符集、描述、关键词等</li><li class="lvl-6"><code>script</code>引入Javascript代码或链接外部Javascript文件</li></ol></li><li class="lvl-3"><p>body：定义网页的主题内容，是HTML文档的一个必要组成部分，包含了所有对用户可见的内容，如文本、图像、链接、段落、标题、表格、表单等。</p></li></ol><h1>常用HTML元素</h1><h3 id="1-标题标签，作为标题使用，根据重要性递减">1. 标题标签，作为标题使用，根据重要性递减</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>......<br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-段落标签，用于定义段落，可以将整个网页分为若干个段落">2. 段落标签，用于定义段落，可以将整个网页分为若干个段落</h3><pre><code class="hljs">`&lt;p&gt;&lt;/p&gt;`</code></pre><h3 id="3-换行标签和水平分割线标签，单标签">3. 换行标签和水平分割线标签，单标签</h3><ul class="lvl-0"><li class="lvl-2"><p>换行<code>&lt;br /&gt;</code>文本强制换行显示</p></li><li class="lvl-2"><p>水平分割线：<code>&lt;hr/&gt;</code>插入水平分割线</p></li></ul><h3 id="4-文本格式化标签">4. 文本格式化标签</h3><table><thead><tr><th style="text-align:left">标签名</th><th style="text-align:left">效果</th><th style="text-align:left">标签名</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;strong&gt;&lt;/strong&gt;</code></td><td style="text-align:left">加粗</td><td style="text-align:left"><code>&lt;b&gt;&lt;/b&gt;</code></td><td style="text-align:left">加粗</td></tr><tr><td style="text-align:left"><code>&lt;em&gt;&lt;/em&gt;</code></td><td style="text-align:left">倾斜</td><td style="text-align:left"><code>&lt;i&gt;&lt;/i&gt;</code></td><td style="text-align:left">倾斜</td></tr><tr><td style="text-align:left"><code>&lt;ins&gt;&lt;/ins&gt;</code></td><td style="text-align:left">下划线</td><td style="text-align:left"><code>&lt;u&gt;&lt;/u&gt;</code></td><td style="text-align:left">下划线</td></tr><tr><td style="text-align:left"><code>&lt;del&gt;&lt;/del&gt;</code></td><td style="text-align:left">删除线</td><td style="text-align:left"><code>&lt;s&gt;&lt;/s&gt;</code></td><td style="text-align:left">删除线</td></tr></tbody></table><h3 id="5-盒子标签">5. 盒子标签</h3><p><code>&lt;div&gt;&lt;/div&gt;</code>一行只能放一个<code>&lt;span&gt;&lt;/span&gt;</code>一行能放多个</p><h3 id="6-图像标签，单标签">6. 图像标签，单标签</h3><p><code>&lt;img /&gt;</code></p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">作用</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">alt</td><td style="text-align:left">替换文本</td><td style="text-align:left">图片无法显示时候显示的文字</td></tr><tr><td style="text-align:left">title</td><td style="text-align:left">提示文本</td><td style="text-align:left">鼠标悬停在图片上面时候显示的文字</td></tr><tr><td style="text-align:left">width</td><td style="text-align:left">图片的宽度</td><td style="text-align:left">值为数字</td></tr><tr><td style="text-align:left">height</td><td style="text-align:left">图片的高度</td><td style="text-align:left">值为数字</td></tr></tbody></table><h3 id="7-超链接标签">7. 超链接标签</h3><p><code>&lt;a href=&quot;&quot; target = &quot;&quot;&gt;链接文本&lt;/a&gt;</code></p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">href</td><td style="text-align:center">用于指定链接目标的ur地址，(必须属性)当为标签应用href属性时，它就具有了超链接的功能；</td></tr><tr><td style="text-align:center">target</td><td style="text-align:center">用于指定链接页面的打开方式，其中_self为默认值(在本窗口中打开)，_ blank为在新窗口中打开方式</td></tr></tbody></table><h3 id="8-表格标签">8. 表格标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span> <span class="hljs-comment">&lt;!-- 用于定义表格的标题部分 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 表示表格的一行 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>列标题1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span> <span class="hljs-comment">&lt;!-- 表示表格的表头单元格 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>列标题2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>列标题3<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span> <span class="hljs-comment">&lt;!-- 用于定义表格的主体部分 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行1，列1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-comment">&lt;!-- 表示表格的数据单元格 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行1，列2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行1，列3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行2，列1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行2，列2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行2，列3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><table border="1">  <thead> <!-- 用于定义表格的标题部分 -->    <tr>  <!-- 表示表格的一行 -->      <th>列标题1</th> <!-- 表示表格的表头单元格 -->      <th>列标题2</th>      <th>列标题3</th>    </tr>  </thead>  <tbody> <!-- 用于定义表格的主体部分 -->    <tr>      <td>行1，列1</td> <!-- 表示表格的数据单元格 -->      <td>行1，列2</td>      <td>行1，列3</td>    </tr>    <tr>      <td>行2，列1</td>      <td>行2，列2</td>      <td>行2，列3</td>    </tr>  </tbody></table><p>常用属性：常用属性：</p><ul class="lvl-0"><li class="lvl-4"><p>border：表示表格的边框宽度，单位是像素，即px；</p></li><li class="lvl-4"><p>rowspan：表示多行合并，可以指定具体要合并的行数；(不要忘记删除多余的单元格)</p></li><li class="lvl-4"><p>colspan：表示多列合并，可以指定具体要合并的列数；(不要忘记删除多余的单元格)</p></li><li class="lvl-4"><p>cellpadding：表示单元格边缘与其单元格内容之间的空白间距；</p></li><li class="lvl-4"><p>cellspacing：表示单元格之间的空白间距；</p></li><li class="lvl-4"><p>width：表示表格的宽度；</p></li><li class="lvl-4"><p>align：表示表格相对周围元素的对齐方式。</p></li></ul><h3 id="9-列表标签">9. 列表标签</h3><p>分为：有序列表、无序列表、自定义列表</p><ul class="lvl-0"><li class="lvl-2"><p>无序列表：使用<code>&lt;ul&gt;</code>标签，里面放着<code>&lt;li&gt;</code>标签，此列项目使用粗体圆点进行标记</p><p><strong><code>&lt;ul&gt;&lt;/ul&gt;</code>里只能嵌套<code>&lt;li&gt;</code>标签</strong></p><p><strong><code>&lt;li&gt;&lt;/li&gt;</code>中可以放任何标签</strong></p><p>type属性可以指定列表项的符号类型，如<code>disc</code>：小圆点，<code>circle</code>：空心圆圈，<code>square</code>：方块</p></li><li class="lvl-2"><p>有序列表：使用<code>&lt;ol&gt;</code>标签，里面放着<code>&lt;li&gt;</code>标签，项目列表使用数字进行标记</p><p><strong><code>&lt;ol&gt;&lt;/ol&gt;</code>中只能嵌套<code>&lt;li&gt;</code>标签</strong></p><p>type属性可以指定列表项的符号类型，如<code>i</code>：罗马数字开始</p><p><code>start</code>属性：指定起始编号</p></li><li class="lvl-2"><p>自定义列表：使用<code>&lt;dl&gt;</code>标签，<code>&lt;dt&gt;</code>标签用来定义项目/名字，<code>&lt;dd&gt;</code>描述每一个项目/名字</p></li></ul><p><strong><code>&lt;dl&gt;&lt;/dl&gt;</code>里面只能包含<code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>无序列表:<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Tea<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>有序列表:<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Tea<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>自定义列表:<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>- black hot drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>- white cold drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="10-表单标签">10.表单标签</h3><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;form&gt; &lt;/form&gt;</code>:表单域标签，表单域就是一个包含表单元素的区域</p></li><li class="lvl-2"><p><code>&lt;input/&gt;</code>:输入表单元素</p></li><li class="lvl-2"><p><code>&lt;lable&gt;&lt;lable&gt;</code>:绑定一个表单元素，当点击lable标签内的文本时，会自动将焦点转到对应的表单元素上，lable的for属性必须得与相关元素的id属性相同</p></li><li class="lvl-2"><p><code>&lt;select&gt;&lt;/select&gt;</code>:下拉表单元素，用于定义一个下拉列表</p></li><li class="lvl-2"><p><code>&lt;option&gt;&lt;/option&gt;</code>:下拉列表中元素，定义selected = “selected”属性时，当前项为默认选中项</p></li><li class="lvl-2"><p><code>&lt;textarea&gt;&lt;/textarea&gt;</code>文本域元素，用于定义一个多行文本输入框，cols属性规定每行的字符数，rows属性规定显示的行数</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 文本输入框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 密码输入框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密码:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 单选按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>性别:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 复选框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;subscribe&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;subscribe&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;subscribe&quot;</span>&gt;</span>订阅推送信息<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 下拉列表 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span>国家:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span>CN<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;usa&quot;</span>&gt;</span>USA<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;uk&quot;</span>&gt;</span>UK<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 提交按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>标签的常用属性：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">属性值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">type</td><td style="text-align:center">见下表</td><td style="text-align:center">用于设置标签的不同形式</td></tr><tr><td style="text-align:center">value</td><td style="text-align:center">用户自定义</td><td style="text-align:center">设置input元素的默认值</td></tr></tbody></table><p>标签type属性值</p><table><thead><tr><th style="text-align:center">属性值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">button</td><td style="text-align:center">定义可点击按钮</td></tr><tr><td style="text-align:center">checkbox</td><td style="text-align:center">定义复选框，一组复选框name属性必须相同</td></tr><tr><td style="text-align:center">password</td><td style="text-align:center">定义密码字段，该字段中的字符被掩码</td></tr><tr><td style="text-align:center">radio</td><td style="text-align:center">定义单选按钮，一组单选按钮的name属性必须相同</td></tr><tr><td style="text-align:center">reset</td><td style="text-align:center">定义重制按钮，清除表单中的所有数据</td></tr><tr><td style="text-align:center">submit</td><td style="text-align:center">定义提交按钮，提交到action属性指定的地址</td></tr><tr><td style="text-align:center">text</td><td style="text-align:center">定义单行的输入字段，用户可在其中输入文本，默认宽度为20字符</td></tr></tbody></table><h3 id="11-注释和特殊字符">11.注释和特殊字符</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 我是注释 --&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">特殊字符</th><th style="text-align:center">描述</th><th style="text-align:center">字符代码</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">空格符</td><td style="text-align:center">&amp;nbsp;</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于号</td><td style="text-align:center">&amp;lt;</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于号</td><td style="text-align:center">&amp;gt;</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">和</td><td style="text-align:center">&amp;amp;</td></tr><tr><td style="text-align:center">±</td><td style="text-align:center">正负号</td><td style="text-align:center">\plusmn;</td></tr><tr><td style="text-align:center">×</td><td style="text-align:center">乘号</td><td style="text-align:center">&amp;times;</td></tr><tr><td style="text-align:center">÷</td><td style="text-align:center">除号</td><td style="text-align:center">&amp;divide;</td></tr></tbody></table><h3 id="12-常用的HTML纯语义话标签">12.常用的HTML纯语义话标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--标题头部区域内容(用于页面或页面中的一块区域)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--标题脚部区域内容(用于页面或页面中的一块区域) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--表示一个包含在HTML文档中的独立部分，它没有更具体的语义元素来表示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--顾名思义，用来定义文章的部分。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--用来表示跟当前页面的内容没有很相关的部分，通常用于显示侧边栏或者补充的内容。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--一般表示此部分是导航栏--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br></code></pre></td></tr></table></figure><h1>分类（针对元素显示模式）</h1><table><thead><tr><th style="text-align:center">元素模式</th><th style="text-align:center">元素排列</th><th style="text-align:center">设置样式</th><th style="text-align:center">默认宽度</th><th style="text-align:center">包含</th></tr></thead><tbody><tr><td style="text-align:center">块级元素</td><td style="text-align:center">一行只能放一个</td><td style="text-align:center">可以设置宽度高度</td><td style="text-align:center">容器的100%</td><td style="text-align:center">标题标签，段落标签，换行标签，水平分割线，div</td></tr><tr><td style="text-align:center">行内元素</td><td style="text-align:center">一行可以放多个</td><td style="text-align:center">不可以直接设置宽度高度</td><td style="text-align:center">它本身内容的宽度</td><td style="text-align:center">span 图像标签 文本格式化标签 输入标签</td></tr><tr><td style="text-align:center">行内块元素</td><td style="text-align:center">一行可以放多个</td><td style="text-align:center">可以设置宽度高度</td><td style="text-align:center">它本身内容的宽度</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 定位</title>
    <link href="/2024/02/29/CSS-%E5%AE%9A%E4%BD%8D/"/>
    <url>/2024/02/29/CSS-%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1>定位 position</h1><p><strong>什么是定位？</strong></p><p>定位的整个想法是允许我们覆盖上面描述的基本文档流行为，以产生有趣的效果。如果你想稍微改变布局中一些盒子的位置，使它们的默认布局流程位置稍微有点古怪，不舒服的感觉呢？定位是你的工具。或者，如果你想要创建一个浮动在页面其他部分顶部的 UI 元素，并且/或者始终停留在浏览器窗口内的相同位置，无论页面滚动多少？定位使这种布局工作成为可能。</p><p>CSS提供了许多不同类型的定位，你可以对HTML元素生效。要使某个元素上的特定类型的定位，我们使用<code>position</code>属性。</p><img src="/2024/02/29/CSS-%E5%AE%9A%E4%BD%8D/1.png" class="" title="这是图片的说明"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.son1</span>&#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;<br>&#125;//设置class为son1的盒子为绝对定位，距离父元素上边线<span class="hljs-number">10px</span><br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">语义</th></tr></thead><tbody><tr><td style="text-align:center">static</td><td style="text-align:center">静态定位</td></tr><tr><td style="text-align:center">relative</td><td style="text-align:center">相对定位</td></tr><tr><td style="text-align:center">absolute</td><td style="text-align:center">绝对定位</td></tr><tr><td style="text-align:center">fixed</td><td style="text-align:center">固定定位</td></tr><tr><td style="text-align:center">sticky</td><td style="text-align:center">粘性定位</td></tr></tbody></table><h2 id="静态定位">静态定位</h2><p>静态定位是每个元素获取的默认值——它只是意味着“将元素放入它在文档布局流中的正常位置”——这里没有什么特别的</p><h2 id="相对定位">相对定位</h2><p>相对定位是我们将要看的第一个位置类型。它与静态定位非常相似，但是他有这几个特点</p><ul class="lvl-0"><li class="lvl-2"><p>不脱离标准流，保留原来位置</p></li><li class="lvl-2"><p>参考点：<strong>原来的自身位置</strong></p></li></ul><p>参考点是原来的自身位置，那么如何改变元素位置？</p><h2 id="介绍top、bottom、left-和-right">介绍top、bottom、left 和 right</h2><p><code>top</code>,<code>bottom</code>,<code>left</code>,<code>right</code>来精确制定要将定位元素移动到的位置。</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">语义</th></tr></thead><tbody><tr><td style="text-align:center">top</td><td style="text-align:center">定位元素距离其父元素的上边线的距离</td></tr><tr><td style="text-align:center">bottom</td><td style="text-align:center">定位元素距离其父元素的下边线的距离</td></tr><tr><td style="text-align:center">right</td><td style="text-align:center">定位元素距离其父元素的右边线的距离</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">定位元素距离其父元素的左边线的距离</td></tr></tbody></table><h2 id="绝对定位">绝对定位</h2><p>绝对定位带来了非常不同的结果，他有如下几个特点</p><ul class="lvl-0"><li class="lvl-2"><p>脱离标准流，不占用原来位置</p></li><li class="lvl-2"><p>参考点：离自己最近的设置了定位的父元素移动</p></li><li class="lvl-2"><p>如果没有祖先元素，或者祖先元素没有定位，则以浏览器为参照物</p></li><li class="lvl-2"><p>行内元素设置了固定定位和绝对定位，会转为块。</p></li></ul><h2 id="固定定位">固定定位</h2><p>还有一种类型的定位覆盖——fixed。这与绝对定位的工作方式完全相同，只有一个主要区别，<strong>固定定位参考点永远是浏览器窗口</strong>，这意味着你可以利用固定定位创建导航菜单之类的元素。</p><h2 id="粘性定位">粘性定位</h2><p>还有一个可用的位置称为sticky，它基本上是相对定位和固定定位的混合体，有着如下几个特点</p><ul class="lvl-0"><li class="lvl-2"><p>以浏览器的窗口为参照点移动元素（固定定位）</p></li><li class="lvl-2"><p>占有原来的位置，不脱离标准流（相对定位）</p></li><li class="lvl-2"><p>必须添加<code>top</code>,<code>bottom</code>,<code>left</code>,<code>right</code>其中一个才有效，跟页面滚动搭配使用，例如，它可用于使导航栏随页面滚动直到特定点，然后粘贴在页面顶部。</p></li></ul><h2 id="“子绝父相”的思想">“子绝父相”的思想</h2><p>子级使用绝对定位，父级则需要相对定位</p><ul class="lvl-0"><li class="lvl-2"><p>父盒子需要加定位限制子盒子在父盒子内显示</p></li><li class="lvl-2"><p>父盒子布局时，需要占有位置</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 浮动布局</title>
    <link href="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
    <url>/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>在说浮动之前，我们先来了解一下<strong>标准流</strong>。</p><ul class="lvl-0"><li class="lvl-2">标准流又称为普通流，是浏览器<strong>默认</strong>的排版方式。</li><li class="lvl-2">标准流中元素会自动按照从左往右从上往下进行排列。</li></ul><h1>浮动 float</h1><p><strong>什么是浮动？</strong></p><p>使元素脱离了标准流，向左或向又移动，直到碰到父元素或另一个浮动元素的边缘为止。</p><p>最初，引入<code>float</code>属性是为了能让Web开发人员实现简单的布局，包括在一列文本中浮动的图像，文字环绕在它的左边或右边。你可能在报纸版面看到过。</p><p><strong>让盒子浮动起来</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.son1</span>&#123;<br>    <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br>&#125; //设置class为son1的盒子向左浮动<br></code></pre></td></tr></table></figure><p>参数</p><table><thead><tr><th style="text-align:center">属性值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">none</td><td style="text-align:center">元素不浮动</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">元素向左浮动</td></tr><tr><td style="text-align:center">right</td><td style="text-align:center">元素向右浮动</td></tr></tbody></table><h2 id="特性">特性</h2><ol><li class="lvl-3"><p>加了浮动的元素盒子是“浮起来”的，脱离了标准流，漂浮在其他标准盒子上，原来的位置空了下来，漏给了标准流盒子</p></li><li class="lvl-3"><p>浮动元素具有<strong>行内块元素</strong>特性</p><ol><li class="lvl-6">任何元素都可以浮动，不管之前是什么模式的元素，添加浮动之后都具有行内块元素相似的特性。</li><li class="lvl-6">元素设置浮动后，原来设置的宽高起作用，默认在当前包含块左上一排，如果前面有块级元素，会排在元素的下面。</li></ol></li></ol><img src="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/1.png" class="" title="这是图片的说明"><ol start="3"><li class="lvl-6"><p>如果原来没有设置宽高，浮动后根据内容决定大小</p></li></ol><img src="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/2.png" class="" title="这是图片的说明"><img src="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/3.png" class="" title="这是图片的说明"><ol start="3"><li class="lvl-3"><p>浮动的元素是相互贴靠在一起的(<strong>没有缝隙</strong>)，如果父级宽度装不下这些浮动的盒子，多出的盒子会<strong>另起一行</strong>对齐。</p></li><li class="lvl-3"><p>浮动元素<strong>不会遮挡</strong>标准流中的文字。</p></li></ol><h2 id="清除浮动">清除浮动</h2><p>我们发现，一个浮动元素会被移出正常文档流，且其他元素会显示在它的下方。如果我们不想让剩余元素也收到浮动元素的影响，我们需要<strong>清除浮动</strong></p><ul class="lvl-0"><li class="lvl-2"><p>清除浮动的本质是<strong>清除浮动造成的影响</strong></p></li><li class="lvl-2"><p>如果父盒子本身有高度，则不需要清除浮动</p></li><li class="lvl-2"><p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了。</p></li><li class="lvl-2"><p>清除浮动主要是为了解决父级元素因为子级浮动引起的内部高度为0的问题</p></li></ul><h3 id="清除浮动的方法">清除浮动的方法</h3><ol><li class="lvl-3"><p>额外标签法</p></li><li class="lvl-3"><p>父级添加<code>overflow</code>属性</p></li><li class="lvl-3"><p>父级添加<code>after</code>伪元素</p></li><li class="lvl-3"><p>父级添加双伪元素</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS Flex布局</title>
    <link href="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/"/>
    <url>/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1>flex布局的基本概念</h1><ul class="lvl-0"><li class="lvl-2">flex布局是一种一维的布局模型，它给子元素之间提供了强大的空间分布和对齐能力。</li><li class="lvl-2">我们之所以说flex是一种一维的布局，是因为一个flex容器一次只能处理一个维度上的元素布局，一行或者一列。</li><li class="lvl-2">采用flex布局的元素，称为<strong>flex容器</strong>，它的所有子元素自动成为容器成员，称为<strong>flex项目</strong>，容器存在两根轴，默认项目按照主轴排列。</li></ul><h1>flexbox的两根轴线</h1><p>当使用flex布局时，首先应该想到两根轴线——主轴和交叉轴，主轴由<code>flex-direction</code>定义，另一根轴垂直于它，flexbox的所有属性都跟这两根轴线有关。</p><p>首先，先设置flex容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;<br>    <span class="hljs-attribute">display</span>: flex | inline-flex; //块元素使用<span class="hljs-attribute">flex</span>，行内块元素使用inline-<span class="hljs-attribute">flex</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="容器属性">容器属性</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-direction</code></p></li><li class="lvl-2"><p><code>flex-wrap</code></p></li><li class="lvl-2"><p><code>flex-flow</code></p></li><li class="lvl-2"><p><code>justify-content</code></p></li><li class="lvl-2"><p><code>align-items</code></p></li><li class="lvl-2"><p><code>align-content</code></p></li></ul><h2 id="主轴">主轴</h2><p>主轴由<code>flex-direction</code>定义，可以取四个值</p><ul class="lvl-0"><li class="lvl-2"><p><code>row</code></p></li><li class="lvl-2"><p><code>row-reverse</code></p></li><li class="lvl-2"><p><code>column</code></p></li><li class="lvl-2"><p><code>column-reverse</code></p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>row和row-reverse分别是水平排列和水平逆序排列</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/1.svg" class="" title="这是图片的说明"><ul class="lvl-0"><li class="lvl-2"><p>column 和 column-reverse 分别是垂直排列和垂直逆序排列</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/2.svg" class="" title="这是图片的说明"><h2 id="交叉轴">交叉轴</h2><p>交叉轴垂直于主轴，所以如果你的<code>flex-direction</code>设置成了<code>row</code>或者<code>row-reverse</code>的话，交叉轴的方向就是沿着上下方向延伸的。</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/3.svg" class="" title="这是图片的说明"><p>如果主轴方向设成了<code>column</code>或者<code>column-reverse</code>交叉轴就是水平方向</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/4.svg" class="" title="这是图片的说明"><h1>用 flex-wrap 实现多行 Flex 容器</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-wrap</span>: no-wrap | wrap | wrap-reverse;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>nowrap</code> （默认）不换行</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/5.png" class="" title="这是图片的说明"><ul class="lvl-0"><li class="lvl-2"><p><code>wrap</code> 换行，第一行在上方</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/6.png" class="" title="这是图片的说明"><ul class="lvl-0"><li class="lvl-2"><p><code>wrap-reverse</code> 换行，第一行在下方</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/7.png" class="" title="这是图片的说明"><h1>简写属性 flex-flow</h1><p>你可以将两个属性 <code>flex-direction</code> 和 <code>flex-wrap</code> 组合为简写属性 <code>flex-flow</code>。第一个指定的值为 <code>flex-direction</code> ，第二个指定的值为 <code>flex-wrap</code>.</p><h1>元素间的对齐和空间分配</h1><p>Flexbox 的一个关键特性是能够设置 flex 元素沿主轴方向和交叉轴方向的对齐方式，以及它们之间的空间分配。</p><h2 id="align-items">align-items</h2><p><code>align-items</code>属性可以使元素在交叉轴方向对齐</p><p>这个属性的初始值为<code>stretch</code>，这就是为什么 flex 元素会默认被拉伸到最高元素的高度。实际上，它们被拉伸来填满 flex 容器——最高的元素定义了容器的高度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">align-items</span>:flex-start | flex-end | center | baseline | stretch;<br>//Streth 拉伸（子元素不设置高度时的默认值)<br></code></pre></td></tr></table></figure><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/9.png" class="" title="这是图片的说明"><h2 id="justify-content">justify-content</h2><p><code>justify-content</code>属性用来使元素在主轴方向上对齐，主轴方向是通过 <code>flex-direction</code> 设置的方向。</p><p>你可以把值设置为<code>space-between</code>，把元素排列好之后的剩余空间拿出来，平均分配到元素之间，所以元素之间间隔相等。或者使用<code>space-around</code>，使每个元素的左右空间相等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;<br></code></pre></td></tr></table></figure><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/8.png" class="" title="这是图片的说明"><h1>flex元素上的属性</h1><p>为了更好地控制flex元素，有四个属性可以作用于他们：</p><ul class="lvl-0"><li class="lvl-2"><p><code>order</code></p></li><li class="lvl-2"><p><code>flex-grow</code></p></li><li class="lvl-2"><p><code>flex-shrink</code></p></li><li class="lvl-2"><p><code>flex-basis</code></p></li></ul><p>在考虑这几个属性的作用之前，需要先了解一下<strong>可用空间</strong>这个概念，这几个flex属性其实就是改变了flex容器中的可用空间的行为，同时，可用空间对于flex元素的对齐行为也是很重要的。</p><p>假设在 1 个 500px 的容器中，我们有 3 个 100px 宽的元素，那么这 3 个元素需要占 300px 的宽，剩下 200px 的可用空间。在默认情况下，flexbox 的行为会把这 200px 的空间留在最后一个元素的后面。</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/10.svg" class="" title="这是图片的说明"><p>如果期望这些元素能自动地扩展去填充满剩下的空间，那么我们需要去控制可用空间在这几个元素间如何分配，这就是元素上的那些 flex 属性要做的事。</p><h2 id="order属性">order属性</h2><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/11.png" class="" title="这是图片的说明"><h2 id="Flex-元素属性：flex-grow">Flex 元素属性：flex-grow</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p></li><li class="lvl-2"><p>如果容器压根就没有剩余空间，那么即使设置了<code>flex-grow</code>也不会生效。</p></li><li class="lvl-2"><p><code>flex-grow</code>的默认值是0，子项目不做任何比例拉伸，如果将三个子项目的flex-grow属性都设为1，那么他们将按照1:1:1的比例分配剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p></li></ul><h2 id="Flex-元素属性：flex-shrink">Flex 元素属性：flex-shrink</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p></li><li class="lvl-2"><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p></li><li class="lvl-2"><p>负值对该属性无效，如果容器还有剩余空间，同样设置<code>flex-shrink</code>也是无效的。</p></li><li class="lvl-2"><p>如果不希望压缩，我们可以选择换行，只需要设置<code>flex-wrap</code>为<code>wrap</code>就好。</p></li></ul><h2 id="Flex-元素属性：-flex-basis">Flex 元素属性： flex-basis</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-basis</code> 定义了该元素的空间大小，flex 容器里除了元素所占的空间以外的富余空间就是可用空间。该属性的默认值是 <code>auto</code>。此时，浏览器会检测这个元素是否具有确定的尺寸。在上面的例子中，所有元素都设定了宽度（width）为 100px，所以 <code>flex-basis</code> 的值为 100px。</p></li><li class="lvl-2"><p>如果没有给元素设定尺寸，<code>flex-basis</code> 的值采用元素内容的尺寸。这就解释了：我们给只要给 Flex 元素的父元素声明 <code>display: flex</code>，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</p></li></ul><h2 id="Flex属性的简写">Flex属性的简写</h2><ul class="lvl-0"><li class="lvl-2"><p>flex属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p></li><li class="lvl-2"><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p></li><li class="lvl-2"><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法——冒泡排序</title>
    <link href="/2023/11/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/11/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>冒泡排序(Bubble Sort)是一种简单，直观的排序算法，它通过比较相邻两个数据，按照从小到大或者从大到小的顺序进行交换，就像一个泡泡冒上去一样，故得名冒泡排序</p></blockquote><h1 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h1><p>以从小到大为例，冒泡算法是这样实现的：</p><p>遍历原始数据，从第一个数开始，到<strong>倒数第二个</strong>数结束，比较当前数和下一个数的大小，如果当前数比下一个数大，则交换这两个数，这样可以将最大的数转移到末尾，接下来再次遍历，但到<strong>倒数第三个</strong>数结束，可以将第二大的数转移到倒数第二位，以此类推。</p><p>动图演示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="动图演示"></p><p>优点：空间复杂度低，稳定性高</p><p>缺点：时间复杂度，效率低</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bubblesort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span> i, j, temp;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<span class="hljs-comment">//外部循环 </span><br><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n - i; j++)&#123;<span class="hljs-comment">//内部循环 </span><br><span class="hljs-keyword">if</span>(a[j] &gt; a[j + <span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//比较相邻元素大小 </span><br>temp = a[j];<span class="hljs-comment">//交换值 </span><br>a[j] = a[j + <span class="hljs-number">1</span>];<br>a[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<span class="hljs-comment">//写入数据 </span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>&#125;<br>bubblesort(a,<span class="hljs-number">10</span>);<span class="hljs-comment">//排序 </span><br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<span class="hljs-comment">//输出数据 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>&#125;<br> <br>&#125; <br></code></pre></td></tr></table></figure><p>输入数据</p><p><code>2 4 1 3 7 9 6 5 8 10</code></p><p>输出数据</p><p><code>1 2 3 4 5 6 7 8 9 10</code></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言库函数(快速排序)--qsort()</title>
    <link href="/2023/11/20/C%E8%AF%AD%E8%A8%80%E5%BA%93%E5%87%BD%E6%95%B0-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-qsort/"/>
    <url>/2023/11/20/C%E8%AF%AD%E8%A8%80%E5%BA%93%E5%87%BD%E6%95%B0-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-qsort/</url>
    
    <content type="html"><![CDATA[<blockquote><p>qsort()函数是一种用于对数组快速排序的函数，他是一个通用的排序函数，支持对不同类型的元素进行排序</p></blockquote><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>qsort()是包含在C语言标准库&lt;stdlib.h&gt;中的函数，所以想使用该函数应在程序前引用该头文件</p><p><code>#include &lt;stdlib.h&gt;</code></p><h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><p><code>void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</code></p><ul><li><p>base -&gt; 数组名</p></li><li><p>nitems -&gt;元素个数</p></li><li><p>size -&gt; 数组元素所占字节（int,char等所占字节）</p></li><li><p>(*compar)(const void <em>, const void</em>) -&gt; 排序原则（递增，递减等）</p><h2 id="排序原则？"><a href="#排序原则？" class="headerlink" title="排序原则？"></a>排序原则？</h2><p>通过定义一个函数compar，通过这个函数<strong>返回的参数</strong>来去确定排序规则</p><p><strong>注意</strong>：compar函数中参数需要以<strong>const void *a,const void *b**的形式来定义，表示a，b的类型是“未确定”（void），在return时候进行强制类型转换为int型，</strong>*(int*)a-*(int*)b**表示递增顺序，如果递减只需要更换a和b的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> &#123;<br><span class="hljs-keyword">return</span> *(<span class="hljs-type">int</span>*)a-*(<span class="hljs-type">int</span>*)b;<span class="hljs-comment">//递增</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="不同类型元素排序"><a href="#不同类型元素排序" class="headerlink" title="不同类型元素排序"></a>不同类型元素排序</h1><p>对于不同的类型，只需要改变compar函数就可以</p><h2 id="整形（int）"><a href="#整形（int）" class="headerlink" title="整形（int）"></a>整形（int）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">int</span>*)a-*(<span class="hljs-type">int</span>*)b;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点型（double）"><a href="#浮点型（double）" class="headerlink" title="浮点型（double）"></a>浮点型（double）</h2><p><strong>注意！浮点数存在精度损失<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="浮点数并不精确，5.000实际上可能是5.000000000003">[1]</span></a></sup>的问题，运算可能会出错，所以我们选择比较的方式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">double</span>*)a&gt;*(<span class="hljs-type">double</span>*)b?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>;<span class="hljs-comment">//三目运算符，如果前大于后，输出1，反之输出-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符型（char）"><a href="#字符型（char）" class="headerlink" title="字符型（char）"></a>字符型（char）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">char</span>*)a-*(<span class="hljs-type">char</span>*)b;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>升序排序一个10位数数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">int</span>*)a-*(<span class="hljs-type">int</span>*)b;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>&#125;;<br>    qsort(a,<span class="hljs-number">10</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>),compar);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><p><code>1 2 3 4 5 6 7 8 9 10</code></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>浮点数并不精确，5.000实际上可能是5.000000000003<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中常用的字符串函数</title>
    <link href="/2023/11/20/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/"/>
    <url>/2023/11/20/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>想要在c语言中处理字符串，你需要引用&lt;string.h&gt;头文件</li></ul><h2 id="处理字符串的函数"><a href="#处理字符串的函数" class="headerlink" title="处理字符串的函数"></a>处理字符串的函数</h2><h3 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h3><p>函数声明<br><code>size_t strlen (const char *str);</code></p><p>作用：</p><p>返回字符串的长度（’\0’之前的长度，不包括’\0’）</p><p><strong>注意</strong>：</p><p>参数指向的字符串必须要以‘\0’结束</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;hello&quot;</span>;<br>    n = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为5。</p><h3 id="strcpy函数"><a href="#strcpy函数" class="headerlink" title="strcpy函数"></a>strcpy函数</h3><p>函数声明</p><p><code>char * strcpy(char * destination,const * source);</code></p><p>作用：</p><p>把source字符串的内容复制到destination中</p><p><strong>注意</strong>：</p><p>目标空间必须足够大能够存放源字符串</p><p>目标空间不可为”const”</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;world&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str1);<span class="hljs-comment">//操作前的str1</span><br>    <span class="hljs-built_in">strcpy</span>(str1,str2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str1);<span class="hljs-comment">//操作后的str1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">hello<span class="hljs-comment">//操作前的str1</span><br>world<span class="hljs-comment">//操作后的str1，strcpy将后面（str2）的值给了str1</span><br></code></pre></td></tr></table></figure><h3 id="strcat函数"><a href="#strcat函数" class="headerlink" title="strcat函数"></a>strcat函数</h3><p>函数声明</p><p><code>char * strcat(char * destination, const char * source)</code>;</p><p>作用：</p><p>将source的内容拼接到destination上</p><p><strong>注意</strong>：</p><p>destination空间必须足够大</p><p>destination不能为”const”</p><p>不可以自己给自己拼接</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">20</span>]=<span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;world&quot;</span>;<br>    <span class="hljs-built_in">strcat</span>(str1,str2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str1);<br>    <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><p><code>helloworld</code></p><h3 id="strcmp函数"><a href="#strcmp函数" class="headerlink" title="strcmp函数"></a>strcmp函数</h3><p>函数原型</p><p><code>int strcmp (const char * str1, const char * str2)</code>;</p><p>作用</p><p>比较两个字符串的大小</p><p>如果字符串1&gt;字符串2，返回值&gt;0</p><p>如果字符串1&#x3D;字符串2，返回值&#x3D;0</p><p>如果字符串1&lt;字符串2，返回值&gt;0</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;1234567&quot;</span>;<br>    <span class="hljs-type">char</span> str3[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;123456789&quot;</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str1,str3));<span class="hljs-comment">//字符串1&lt;字符串2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str2,str2));<span class="hljs-comment">//字符串1=字符串2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str3,str1));<span class="hljs-comment">//字符串1&gt;字符串2</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">-1</span> <span class="hljs-comment">//字符串1&lt;字符串2，返回值&lt;0</span><br><span class="hljs-number">0</span>  <span class="hljs-comment">//字符串1=字符串2，返回值=0</span><br><span class="hljs-number">1</span>  <span class="hljs-comment">//字符串1&gt;字符串2，返回值&gt;0</span><br></code></pre></td></tr></table></figure><h3 id="strstr函数"><a href="#strstr函数" class="headerlink" title="strstr函数"></a>strstr函数</h3><p>函数声明</p><p><code>const char * strstr(const char * str1,const char * str2);</code></p><p>作用：</p><p>在str1中查找str2出现的位置</p><p>返回指向str1中第一次出现的str2的指针，如str2不是str1的一部分，则返回”NULL”</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;ABCDEFG&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;BCD&quot;</span>;<br>    <span class="hljs-type">char</span> str3[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;JOKER&quot;</span>;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(str1, str2) == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//判断str2是不是str1的子串 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,<span class="hljs-built_in">strstr</span>(str1,str2));<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(str1, str3) == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//判断str3是不是str1的子串 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,<span class="hljs-built_in">strstr</span>(str1,str3));<br>&#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">BCDEFG <span class="hljs-comment">//返回第一次出现str2(BCD)及其之后的字符</span><br>NO<span class="hljs-comment">//str3不是str1的子串</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
