<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript 文档对象模型DOM</title>
    <link href="/2024/03/05/JavaScript-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8BDOM/"/>
    <url>/2024/03/05/JavaScript-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8BDOM/</url>
    
    <content type="html"><![CDATA[<h1>DOM树和DOM对象</h1><ul class="lvl-0"><li class="lvl-2">DOM(Document Object Model —— 文档对象模型)是用来呈现以及与任意HTML或者XML文档交互的API</li><li class="lvl-2">DOM是浏览器提供的一套专门用来操作网页内容的功能</li><li class="lvl-2">DOM的作用：开发网页内容特效和实现用户交互</li></ul><h2 id="DOM树">DOM树</h2><ul class="lvl-0"><li class="lvl-2">将HTML文档以树状结构直观的表现出来，我们称之为文档树或DOM树</li><li class="lvl-2">描述网页内容关系的名次</li><li class="lvl-2">作用：<strong>文档树直观的体现了标签与标签之间的关系</strong></li></ul><h2 id="DOM对象">DOM对象</h2><ul class="lvl-0"><li class="lvl-2"><p>DOM对象：浏览器根据HTML标签生成的JS对象</p></li><li class="lvl-2"><p>对象</p><ul class="lvl-2"><li class="lvl-4">所有的标签属性都可以在这个对象上面找到</li><li class="lvl-4">修改这个对象的属性会自动映射到标签上</li></ul></li><li class="lvl-2"><p>DOM的核心思想</p><ul class="lvl-2"><li class="lvl-4">把网页内容当作<strong>对象</strong>处理</li></ul></li><li class="lvl-2"><p>doucument对象</p><ul class="lvl-2"><li class="lvl-4">是DOM里提供的一个对象</li><li class="lvl-4">所以他提供的属性和方法都是用来访问和操作网页内容的</li><li class="lvl-4">网页所有内容都在doucment里</li></ul></li></ul><h1>通过CSS选择器来获取DOM元素</h1><ul class="lvl-0"><li class="lvl-2"><p><strong>查找元素DOM元素就是利用JS选择页面中标签元素</strong></p><ul class="lvl-2"><li class="lvl-4">选择匹配的第一个元素</li></ul></li><li class="lvl-2"><p><code>document.querySelector('CSS选择器')</code></p></li><li class="lvl-2"><p>返回值：CSS选择器匹配的<strong>第一个元素</strong>，一个对象，如果没有匹配不到，返回null</p></li><li class="lvl-2"><p>可以直接修改</p><ul class="lvl-2"><li class="lvl-4">选择匹配的多个元素</li></ul></li><li class="lvl-2"><p><code>document.querySelectorAll('CSS选择器')</code></p></li><li class="lvl-2"><p>参数：包含一个或者多个有效的CSS选择器字符串</p></li><li class="lvl-2"><p>返回值：CSS选择器匹配的NodeList对象</p></li><li class="lvl-2"><p>不能直接操作，只能遍历</p></li><li class="lvl-2"><p>得到的是一个伪数组</p><ul class="lvl-2"><li class="lvl-4">有长度有索引号的数组但是没有数组方法，想要得到里面的每一个对象，则需要通过遍历的方式获得</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> lis = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySeletorAll</span>(<span class="hljs-string">&#x27;.nav li&#x27;</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lis.<span class="hljs-property">length</span>; i++)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lis[i])<span class="hljs-comment">//每个li对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其他方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//根据id获取一个元素</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;nav&#x27;</span>)<br><span class="hljs-comment">//根据标签获取一类元素</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br><span class="hljs-comment">//根据类名获取元素</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;class&#x27;</span>)<br></code></pre></td></tr></table></figure><h1>DOM修改元素内容</h1><h2 id="对象-innerText属性">对象.innerText属性</h2><ul class="lvl-0"><li class="lvl-2"><p>将文本内容添加/更新到任意标签位置</p></li><li class="lvl-2"><p>显示纯文本，不解析标签</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">innerText</span>)<span class="hljs-comment">//123</span><br>box.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;&lt;strong&gt;456&lt;/strong&gt;&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">innerText</span>)<span class="hljs-comment">//&lt;strong&gt;456&lt;/strong&gt;</span><br></code></pre></td></tr></table></figure><h2 id="对象-innerHTML属性">对象.innerHTML属性</h2><ul class="lvl-0"><li class="lvl-2"><p>将文本内容添加/更新到任意标签位置</p></li><li class="lvl-2"><p>会解析标签，多标签建议使用模板字符串</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">innerHTML</span>)<span class="hljs-comment">//123</span><br>box.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&lt;strong&gt;456&lt;/strong&gt;&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(box.<span class="hljs-property">innerHTML</span>)<span class="hljs-comment">//456(加粗)</span><br></code></pre></td></tr></table></figure><h2 id="表单修改属性">表单修改属性</h2><p>表单修改属性比较特殊<br><code>DOM对象.属性值 = 新值</code><br><code>表单.value = '用户名'</code></p><ul class="lvl-0"><li class="lvl-2"><p>innerHTML无法得到表单内部属性</p></li><li class="lvl-2"><p>表单属性添加了就有效果，移除了就没效果，一律用布尔值表示，true为添加，false为删除</p></li><li class="lvl-2"><p>比如：disabked checked</p></li><li class="lvl-2"><p>button按钮用innerHTML修改</p></li></ul><h1>DOM修改常用属性</h1><ul class="lvl-0"><li class="lvl-2"><p>可以通过JS设置/修改元素设想，不如通过src更换照片</p></li><li class="lvl-2"><p>更常见的属性比如：href,title,src等</p></li><li class="lvl-2"><p><code>对象.属性 = 值</code></p></li><li class="lvl-2"><p>模板文字：${变量}插入到字符串中</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;img src = <span class="hljs-string">&quot;./imgs/1.png&quot;</span>/&gt;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getRandom</span>(<span class="hljs-params">N,M</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (M - N + <span class="hljs-number">1</span>)) + N<br>&#125;<br><br><span class="hljs-keyword">const</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title class_">Selector</span>(<span class="hljs-string">&#x27;img&#x27;</span>)<br><span class="hljs-keyword">const</span> random = <span class="hljs-title function_">getRandom</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)<br>img.<span class="hljs-property">src</span> = <span class="hljs-string">`./imgs/<span class="hljs-subst">$&#123;random&#125;</span>.png`</span><span class="hljs-comment">//反引号，模板文字</span><br></code></pre></td></tr></table></figure><h1>修改样式属性</h1><h2 id="通过style属性操作CSS">通过style属性操作CSS</h2><p><code>对象.style.样式属性 = 值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">box.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&#x27;200px&#x27;</span><span class="hljs-comment">//单位</span><br>box.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;hotpink&#x27;</span><span class="hljs-comment">//多组单词采用小驼峰</span><br>box.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&#x27;2px solid blue&#x27;</span><br>box.<span class="hljs-property">style</span>.<span class="hljs-property">borderTop</span> = <span class="hljs-string">&#x27;2px solid red&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="通过操作类名（className）操作CSS">通过操作类名（className）操作CSS</h2><ul class="lvl-0"><li class="lvl-2"><p>适用于修改样式比较多</p></li><li class="lvl-2"><p>新的类名会覆盖原有的类名</p></li><li class="lvl-2"><p><code>元素.className = 'active'</code></p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;nav&quot;</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.nav</span>&#123;<br><span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.box</span>&#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br><span class="hljs-attribute">background-color</span>: skyblue;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nav = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.nav&#x27;</span>)<br>div.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;box&#x27;</span><span class="hljs-comment">//不用加点</span><br>div.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;nav box&#x27;</span><span class="hljs-comment">//保留原有属性</span><br></code></pre></td></tr></table></figure><h2 id="通过classList操作类控制CSS">通过classList操作类控制CSS</h2><ul class="lvl-0"><li class="lvl-2"><p>为了解决className容易覆盖以前的类名，我们可以通过classList的方式追加和删除类名</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//追加一个类</span><br>元素.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;类名&#x27;</span>)<br><span class="hljs-comment">//删除一个类</span><br>元素.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;类名&#x27;</span>)<br><span class="hljs-comment">//切换一个类</span><br>元素.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;类名&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div <span class="hljs-keyword">class</span> = <span class="hljs-string">&quot;nav&quot;</span>&gt;<span class="hljs-number">123</span>&lt;/div&gt;<br><br>.<span class="hljs-property">nav</span>&#123;<br><span class="hljs-attr">color</span>: red;<br>&#125;<br>.<span class="hljs-property">box</span>&#123;<br><span class="hljs-attr">width</span>: 300px;<br><span class="hljs-attr">height</span>: 300px;<br>background-<span class="hljs-attr">color</span>: skyblue;<br><span class="hljs-attr">margin</span>: 100px auto;<br>&#125;<br><br><span class="hljs-keyword">const</span> nav = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.nav&#x27;</span>)<br>nav.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;box&#x27;</span>)<span class="hljs-comment">//不加点</span><br>nav.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;box&#x27;</span>)<br>nav.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;nav&#x27;</span>)<span class="hljs-comment">//有就删掉，没有就加上</span><br></code></pre></td></tr></table></figure><h1>HTML5自定义属性</h1><ul class="lvl-0"><li class="lvl-2"><p>标准属性：天生自带的属性，比如class id title等，也可以使用点语法操作比如：disabled checked selected等</p></li><li class="lvl-2"><p>自定义属性：</p><ul class="lvl-2"><li class="lvl-4">在H5中推出了专门的data-自定义属性</li><li class="lvl-4">在标签上一律以data-开头</li><li class="lvl-4">在DOM对象上一律以dataset对象方式来获取</li></ul></li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div data-id=<span class="hljs-string">&quot;1&quot;</span> data-spm=<span class="hljs-string">&quot;不知道&quot;</span>&gt;<span class="hljs-number">1</span>&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-id</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="hljs-keyword">const</span> one = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<span class="hljs-comment">//取第一个</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one.<span class="hljs-property">dataset</span>.<span class="hljs-property">id</span>)<span class="hljs-comment">//1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one.<span class="hljs-property">dataset</span>.<span class="hljs-property">spm</span>)<span class="hljs-comment">//不知道</span><br></code></pre></td></tr></table></figure><h1>定时器——间歇函数</h1><ul class="lvl-0"><li class="lvl-2"><p>使用场景：自动执行代码，网页倒计时</p></li><li class="lvl-2"><p>开启定时器</p></li><li class="lvl-2"><p><code>setInterval(函数，间隔时间)</code></p></li><li class="lvl-2"><p>每间隔多长时间调用该函数</p></li><li class="lvl-2"><p>时间单位为毫秒</p></li><li class="lvl-2"><p>定时器返回值是一个id</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(1s)<br>&#125;,<span class="hljs-number">1000</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(1s)<br>&#125;<br><br><span class="hljs-keyword">let</span> n = <span class="hljs-built_in">setInterval</span>(fn,<span class="hljs-number">1000</span>)<span class="hljs-comment">//函数名字不需要加括号，n为一个id数字，独一无二</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>关闭定时器</p></li><li class="lvl-2"><p><code>clearInterval(变量名)</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> n = <span class="hljs-built_in">setInterval</span>(fn,<span class="hljs-number">1000</span>)<br><span class="hljs-title function_">clear</span>(n)<br></code></pre></td></tr></table></figure><h1>事件监听</h1><p>什么是事件？</p><ul class="lvl-0"><li class="lvl-2"><p>事件是在编程时系统内发生的动作或者发生的事</p></li></ul><p>什么是事件监听？</p><ul class="lvl-0"><li class="lvl-2"><p>就是让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为绑定事件或者注册事件</p></li></ul><p>语法<br><code>元素对象.addEventListener('事件类型'，要执行的函数)</code></p><p>事件监听三要素：</p><ol><li class="lvl-3"><p>事件源：哪个DOM事件被触发了，要获取DOM元素</p></li><li class="lvl-3"><p>事件类型：用什么方式触发，比如鼠标单击click，鼠标经过mouseover等</p></li><li class="lvl-3"><p>事件调用的函数：要做什么事</p></li></ol><h1>事件监听版本以及鼠标事件</h1><h2 id="事件监听版本">事件监听版本</h2><p>DOM L0</p><ul class="lvl-0"><li class="lvl-4"><p><code>事件源.on事件 = function()&#123;&#125;</code><br>DOM L2</p></li><li class="lvl-4"><p><code>事件源.addEventListener(事件，事件处理函数)</code></p></li></ul><p>区别：</p><ul class="lvl-0"><li class="lvl-2"><p>on方式会被覆盖，addEventListenr方式可被访问多次，拥有事件更多特性，推荐使用</p></li></ul><h2 id="事件类型">事件类型</h2><h3 id="鼠标事件">鼠标事件</h3><p><code>click</code>鼠标点击<code>mouseenter</code>鼠标经过<code>mouseleave</code>鼠标离开</p><h3 id="焦点事件">焦点事件</h3><p><code>focus</code>获得焦点<code>blur</code>失去焦点</p><h3 id="键盘事件">键盘事件</h3><p><code>keydown</code>键盘按下触发<code>keyup</code>键盘抬起触发</p><h3 id="文本事件">文本事件</h3><p><code>input</code>用户输入事件属性选择器[type = xxx]</p><h1>事件对象</h1><p>事件对象是什么？</p><ul class="lvl-0"><li class="lvl-2"><p>也是个对象，这个对象里有事件触发时的相关信息</p></li><li class="lvl-2"><p>例如鼠标点击事件中，事件对象就存了鼠标点在哪个位置等信息使用场景：</p></li><li class="lvl-2"><p>可以判断用户按下哪个键，比如按下回车键可以发布新闻</p></li><li class="lvl-2"><p>可以判断鼠标点击了哪个元素，从而做相应的操作</p></li></ul><h2 id="事件对象常用属性">事件对象常用属性</h2><p>函数的第一个参数就是事件对象<code>function(e)</code><br><code>type</code>获取当前的事件类型<code>clientX/clientY</code>获取光标相对于浏览器可见窗口左上角的位置<code>offsetX/offsetY</code>获取光标相对于当前DOM元素左上角的位置<code>key</code>用户按下的键盘值的值，现在不提倡使用keyCode</p><h1>事件流 事件补货 事件冒泡 阻止冒泡</h1><h2 id="事件流">事件流</h2><ul class="lvl-0"><li class="lvl-2"><p>事件流指的是事件完整执行过程中的流动路径</p></li><li class="lvl-2"><p>假设页面里有个div，当触发事件时，会经历两个阶段，分别是捕获阶段和冒泡阶段</p></li><li class="lvl-2"><p>捕获阶段从父到子，冒泡阶段从子到父</p></li><li class="lvl-2"><p>实际工作都是使用事件冒泡为主</p></li></ul><h2 id="事件捕获">事件捕获</h2><ul class="lvl-0"><li class="lvl-2"><p>从DOM的根元素开始去执行对应的操作</p></li><li class="lvl-2"><p><code>DOM.addEventListener(事件类型，事件处理函数，是否使用捕获机制)</code></p></li><li class="lvl-2"><p>第三个参数传入true代表是捕获阶段触发（很少使用）</p></li><li class="lvl-2"><p>若传入false则代表冒泡阶段触发，默认就是false</p></li><li class="lvl-2"><p>若是用L0事件监听，则只有冒泡阶段，没有捕获</p></li></ul><h2 id="事件冒泡">事件冒泡</h2><ul class="lvl-0"><li class="lvl-2"><p>当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡</p></li></ul><h2 id="阻止冒泡">阻止冒泡</h2><ul class="lvl-0"><li class="lvl-2"><p>冒泡容易影响到父级元素</p></li><li class="lvl-2"><p>若想把事件就限制在当前元素内，就需要阻止事件冒泡</p></li><li class="lvl-2"><p>阻止事件冒泡需要拿到事件对象</p></li><li class="lvl-2"><p><code>事件对象.stopPropagation()</code></p></li><li class="lvl-2"><p>此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效</p></li></ul><h1>解绑事件 mouseover和mouseenter的区别</h1><ul class="lvl-0"><li class="lvl-2"><p>on事件方式，直接使用null覆盖就可以实现事件的解绑</p></li><li class="lvl-2"><p><code>box.onclick = null</code></p></li><li class="lvl-2"><p>addEventListener方式，必须使用</p></li><li class="lvl-2"><p><code>removeEventListener(事件类型，事件处理函数，[获取捕获或者冒泡阶段])</code></p></li><li class="lvl-2"><p>例如：<code>button.removeEventListener('click',fn)</code></p></li><li class="lvl-2"><p>匿名函数无法被解绑</p></li></ul><h2 id="鼠标经过事件">鼠标经过事件</h2><ul class="lvl-0"><li class="lvl-2"><p><code>mouseover</code>和 <code>mouseout</code>会有冒泡效果</p></li><li class="lvl-2"><p><code>mouseenter</code>和 <code>mouseleave</code>没有冒泡效果（推荐）</p></li></ul><h1>事件委托</h1><ul class="lvl-0"><li class="lvl-2"><p>事件委托是利用事件流的特征解决一些开发需求的知识技巧</p><ul class="lvl-2"><li class="lvl-6">优点：减少注册次数，可以提高程序性能</li><li class="lvl-6">原理：事件委托其实是利用事件冒泡的特点。<ul class="lvl-4"><li class="lvl-10">给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件</li><li class="lvl-10">事件需要委托到父级如何找到真正触发的元素？<br><code>事件对象.target.targetName</code></li></ul></li></ul></li></ul><h1>阻止元素默认行为</h1><ul class="lvl-0"><li class="lvl-2"><p>有些情况下需要阻止默认行为的发生，比如阻止链接的跳转，表单域跳转</p></li><li class="lvl-2"><p>语法：<code>e.preventDefault()</code></p></li></ul><h1>页面加载事件和页面滚动事件</h1><ul class="lvl-0"><li class="lvl-2"><p>加载外部资源（如图片、外连CSS和JavaScript等）加载完毕时触发的事件</p></li><li class="lvl-2"><p>为什么要学？</p><ul class="lvl-2"><li class="lvl-6">有些时候需要等页面资源全部处理完了做些事情</li><li class="lvl-6">老代码喜欢把script写在head中，这时候直接找DOM元素找不到</li></ul></li></ul><h2 id="页面加载事件">页面加载事件</h2><ul class="lvl-0"><li class="lvl-2"><p>事件名：load</p></li><li class="lvl-2"><p>监听页面所有资源加载完毕：</p><ul class="lvl-2"><li class="lvl-4">给window添加load文件</li><li class="lvl-4"><code>window.addEventListener('load',function()&#123;执行操作&#125;)</code></li><li class="lvl-4">当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，而无需等到样式全部加载</li><li class="lvl-4"><code>docuement.addEventListener('DOMContentLoaded',function()&#123;执行操作&#125;)</code></li></ul></li></ul><h2 id="元素滚动事件">元素滚动事件</h2><ul class="lvl-0"><li class="lvl-2"><p>很多页面需要检测用户把页面滚动到某个区域后做一些处理，比如固定导航栏，比如返回顶部</p></li><li class="lvl-2"><p>事件名：scroll</p></li><li class="lvl-2"><p>监听整个页面滚动</p></li><li class="lvl-2"><p><code>window.addEventListener('scroll',function()&#123;执行操作&#125;)</code></p></li><li class="lvl-2"><p>使用场景</p><ul class="lvl-2"><li class="lvl-4">我们像要页面滚动一段距离，比如100px，就让某些元素显示i隐藏</li><li class="lvl-4">可以用scroll检测滚动的距离</li></ul></li><li class="lvl-2"><p>获取位置</p></li><li class="lvl-2"><p>scrollLeft和scrollTop属性</p></li><li class="lvl-2"><p>获取被卷去的大小</p></li><li class="lvl-2"><p>获取元素内容往左往上的</p></li><li class="lvl-2"><p>获取HTML元素的写法</p></li><li class="lvl-2"><p><code>document.documentElement</code></p></li><li class="lvl-2"><p>尽量在scroll里获取被卷去的距离</p></li><li class="lvl-2"><p><code>scrollTo</code>方法可以把内容滚动到指定的坐标</p></li><li class="lvl-2"><p><code>window.scrollTo(0,1000)//把页面滚动到y轴1000像素的位置</code></p></li></ul><h1>client家族和offset家族</h1><ul class="lvl-0"><li class="lvl-2"><p>页面尺寸事件</p></li><li class="lvl-2"><p>会在窗口尺寸改变的时候触发事件</p></li><li class="lvl-2"><p><code>resize</code></p></li><li class="lvl-2"><p><code>window.addEventListener('resize',function()&#123;&#125;)</code></p></li><li class="lvl-2"><p>获取元素宽高</p></li><li class="lvl-2"><p>获取元素的课件部分宽高（不包括边框，margin，滚动条等）</p></li><li class="lvl-2"><p>clientWidth 和 clientHeight</p></li><li class="lvl-2"><p>获取宽高：</p><ul class="lvl-2"><li class="lvl-6">获取元素的自身宽高，包含元素自身设置的宽高、padding、border</li><li class="lvl-6">offsetWidth和offsetHeight</li><li class="lvl-6">获取出来的是数值，方便计算</li><li class="lvl-6">注意：获取的是可视宽高，如果盒子是隐藏的，获取的是0</li></ul></li><li class="lvl-2"><p>获取位置：</p><ul class="lvl-2"><li class="lvl-6">获取元素距离自己定位父级元素的左、上距离</li><li class="lvl-6">offsetLeft和offsetTop 注意时只读属性</li></ul></li></ul><h1>日期对象的使用</h1><p>日期对象：可以用来表示时间的对象作用：可以得到当前系统时间实例化：<br>- 在代码中发现了new关键字时，一般将这个操作称为实例化<br>- 创建一个时间对象并获取时间<br>- <code>const date = new Date()</code><br>- 获得指定时间<br>- <code>const date = new Date('2008-8-8')</code></p><ul class="lvl-0"><li class="lvl-2"><p>日期对象方法</p></li><li class="lvl-2"><p>目标能够使用日期对象的方法写出常见日期</p></li></ul><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>getFullYear()</code></td><td style="text-align:center">获得年份</td><td style="text-align:center">获取四位年份</td></tr><tr><td style="text-align:center"><code>getMouth()</code></td><td style="text-align:center">获得月份</td><td style="text-align:center">取值为0～11</td></tr><tr><td style="text-align:center"><code>getDate()</code></td><td style="text-align:center">获取月份中的每一天</td><td style="text-align:center">不同月份取值也不相同</td></tr><tr><td style="text-align:center"><code>getDay()</code></td><td style="text-align:center">获取星期</td><td style="text-align:center">取值为0～6</td></tr><tr><td style="text-align:center"><code>getHours()</code></td><td style="text-align:center">获取小时</td><td style="text-align:center">取值为0～23</td></tr><tr><td style="text-align:center"><code>getMinutes()</code></td><td style="text-align:center">获取分钟</td><td style="text-align:center">取值为0～59</td></tr><tr><td style="text-align:center"><code>getSeconds()</code></td><td style="text-align:center">获取秒</td><td style="text-align:center">取值为0～59</td></tr><tr><td style="text-align:center"><code>date.toLocaleString()</code>格式化日期</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>date.toLocaleDateString()</code></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>date.toLocaleTimeString()</code></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h1>时间戳的使用</h1><ul class="lvl-0"><li class="lvl-2"><p>计算倒计时的效果</p></li><li class="lvl-2"><p>什么是时间戳：</p><ul class="lvl-2"><li class="lvl-6">是指1970年1月1日00时00分00秒起到现在的毫秒数，它是一种特殊的计量事件的方式</li></ul></li><li class="lvl-2"><p>算法：</p><ul class="lvl-2"><li class="lvl-6">将来的时间戳-现在的时间戳=剩余时间毫秒数</li><li class="lvl-6">剩余时间毫秒数转换为剩余时间的年月日时分秒就是倒计时时间</li><li class="lvl-6">比如将来时间戳2000ms-现在时间戳1000ms = 1000ms</li><li class="lvl-6">1000ms转换为就是0h0m1s</li></ul></li><li class="lvl-2"><p>获取时间戳</p><ul class="lvl-2"><li class="lvl-6">使用<code>gettime()</code>方法<ul class="lvl-4"><li class="lvl-10"><code>date.getTime()</code><ul class="lvl-6"><li class="lvl-14">必须实例化</li></ul></li></ul></li><li class="lvl-6">简写 <code>+new Date</code><ul class="lvl-4"><li class="lvl-10">无需实例化</li></ul></li><li class="lvl-6">使用<code>Date.now</code><ul class="lvl-4"><li class="lvl-10">只能得到当前时间戳</li></ul></li></ul></li><li class="lvl-2"><p>转换公式：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">d = <span class="hljs-built_in">parseInt</span>(总秒数/<span class="hljs-number">60</span>/<span class="hljs-number">60</span>/<span class="hljs-number">24</span>)<span class="hljs-comment">//计算天数</span><br>h = <span class="hljs-built_in">parseInt</span>(总秒数/<span class="hljs-number">60</span>/<span class="hljs-number">60</span>%<span class="hljs-number">24</span>)<span class="hljs-comment">//计算小时</span><br>m = <span class="hljs-built_in">parseInt</span>(总秒数/<span class="hljs-number">60</span>%<span class="hljs-number">60</span>)<span class="hljs-comment">//计算分数</span><br>s = <span class="hljs-built_in">parseInt</span>(总秒数%<span class="hljs-number">60</span>)<span class="hljs-comment">//计算当前秒数</span><br></code></pre></td></tr></table></figure><h1>查找DOM节点</h1><ul class="lvl-0"><li class="lvl-2"><p>DOM节点</p><ul class="lvl-2"><li class="lvl-6">DOM树每一个内容都称为节点</li></ul></li><li class="lvl-2"><p>节点类型</p><ul class="lvl-2"><li class="lvl-6">元素节点<ul class="lvl-4"><li class="lvl-10">所有的标签</li><li class="lvl-10">html是根节点</li></ul></li><li class="lvl-6">属性节点<ul class="lvl-4"><li class="lvl-10">所有的属性，比如href</li></ul></li><li class="lvl-6">文本节点<ul class="lvl-4"><li class="lvl-10">所有的文本</li></ul></li><li class="lvl-6">其他</li></ul></li><li class="lvl-2"><p>查找节点</p></li><li class="lvl-2"><p>父节点查找</p></li><li class="lvl-2"><p>返回<strong>最近一级</strong>的父节点，找不到返回null</p></li><li class="lvl-2"><p><code>子元素.parentNode</code></p></li><li class="lvl-2"><p>子节点查找</p></li><li class="lvl-2"><p><code>chileNodes</code></p></li><li class="lvl-2"><p>获得所有子节点</p></li><li class="lvl-2"><p><code>children</code></p></li><li class="lvl-2"><p>仅获得所有元素节点</p></li><li class="lvl-2"><p>返回的还是一个伪数组</p></li><li class="lvl-2"><p>兄弟关系查找</p></li><li class="lvl-2"><p>下一个兄弟节点</p></li><li class="lvl-2"><p><code>nextElementSibling</code>属性</p></li><li class="lvl-2"><p>上一个兄弟节点</p></li><li class="lvl-2"><p><code>previousElementSibling</code>属性</p></li></ul><h1>增加节点</h1><ul class="lvl-0"><li class="lvl-2"><p>比如点击按钮，可以新增一条信息</p></li><li class="lvl-2"><p>创建一个新的节点</p></li><li class="lvl-2"><p>把创建的新的节点放入指定的元素内部</p></li><li class="lvl-2"><p>创建元素节点方法：</p></li><li class="lvl-2"><p><code>document.createElement('标签名')</code></p></li><li class="lvl-2"><p>追加节点</p></li><li class="lvl-2"><p>想要在界面看到，还得插入到某个父元素中</p></li><li class="lvl-2"><p>插入到父元素的最后一个子元素：</p></li><li class="lvl-2"><p><code>父元素.appendChild(要插入的元素)</code></p></li><li class="lvl-2"><p>插入到前面</p></li><li class="lvl-2"><p><code>父元素.insertBefore(要插入的元素,在哪个元素前面)</code></p></li><li class="lvl-2"><p><code>ul.insertBefore(li,ul.children[0])//永远放在第一位</code></p></li><li class="lvl-2"><h1>克隆节点和删除节点</h1></li><li class="lvl-2"><p>克隆节点</p></li><li class="lvl-2"><p><code>元素.cloneNode(布尔值)</code></p></li><li class="lvl-2"><p>cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值</p><ul class="lvl-2"><li class="lvl-6">若为true，则代表克隆时会包含后代节点一起克隆</li><li class="lvl-6">若为false，则代表克隆时不包含后代节点</li><li class="lvl-6">默认为false</li></ul></li><li class="lvl-2"><p>删除节点</p></li><li class="lvl-2"><p>要删除元素必须通过父元素删除</p></li><li class="lvl-2"><p><code>父元素.removeChild(要删除的元素)</code></p></li><li class="lvl-2"><p>若不存在父子关系则删除不成功</p></li></ul><h1>BOM和延迟函数setTimeout</h1><ul class="lvl-0"><li class="lvl-2"><p>BOM（Browser Object Model）是浏览器对象模型</p></li><li class="lvl-2"><p>window对象是一个全局对象，也可以说是Javascript中的顶级对象</p></li><li class="lvl-2"><p>像document、alert()、console.log()这些都是window的属性、基本BOM的属性和方法都是window的。</p></li><li class="lvl-2"><p>所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法</p></li><li class="lvl-2"><p>window对象下的属性和方法调用的时候可以省略window</p></li><li class="lvl-2"><p>定时器——延时函数</p></li><li class="lvl-2"><p><code>setTimeout(回调函数，等待的毫秒数)</code></p></li><li class="lvl-2"><p>只执行一次</p></li><li class="lvl-2"><p>清除延时函数</p></li><li class="lvl-2"><p><code>clearTimeout(timer)</code></p></li><li class="lvl-2"><p>timer是返回的id</p></li></ul><h1>时间循环eventloop</h1><ul class="lvl-0"><li class="lvl-2"><p>JS执行机制</p></li><li class="lvl-2"><p>javaScrpt语言的一大特点就是单线程，也就是说，同一个时间只能做一件事</p></li><li class="lvl-2"><p>这是因为JavaScript这门脚本语言诞生的使命所致——JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOm元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。</p></li><li class="lvl-2"><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉</p></li><li class="lvl-2"><p>为了解决这个问题，利用多核CPU的计算能力，HTML5提出Web Worker 标准，允许JavaScript脚本创建多个线程，于是Js中出现了同步和异步</p></li><li class="lvl-2"><p>同步任务</p><ul class="lvl-2"><li class="lvl-6">同步任务都在主线程上执行，形成一个执行栈</li></ul></li><li class="lvl-2"><p>异步任务</p><ul class="lvl-2"><li class="lvl-6">Js的异步是通过回调函数来实现的</li><li class="lvl-6">普通事件：click resize等</li><li class="lvl-6">资源加载：load error等</li><li class="lvl-6">定时器： setInterval、setTimeout等</li><li class="lvl-6">异步任务相关添加到<strong>任务队列</strong>中（任务队列也被称为消息队列）</li></ul></li></ul><ol><li class="lvl-3"><p>先执行执行栈中的同步任务</p></li><li class="lvl-3"><p>异步任务放入任务队列中</p></li><li class="lvl-4"><p>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>由于主线程不断的重复会的任务，执行任务、再获取任务、再执行，所以这种机制叫做事件循环</p></li></ul><h1>location对象</h1><ul class="lvl-0"><li class="lvl-2"><p>location的数据类型是对象，它拆分并保存了URL地址的各个组成部分</p></li><li class="lvl-2"><p>常用属性和方法：</p><ol><li class="lvl-7">href 经常用 js 的方式跳转页面</li><li class="lvl-7">search 获取地址中携带的参数，符号？后面部分</li><li class="lvl-7">hash 属性获取地址中的哈希值，符号 # 后面部分</li><li class="lvl-7"><code>location.reload()</code>刷新页面（）加true 强制刷新</li></ol></li></ul><h1>navigator对象和history对象</h1><ul class="lvl-0"><li class="lvl-2"><p>navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息</p></li><li class="lvl-2"><p>常用属性和方法：</p></li><li class="lvl-2"><p>useAgent 检测浏览器的版本及平台</p></li><li class="lvl-2"><p>history对象</p></li><li class="lvl-2"><p>back()可以后退功能</p></li><li class="lvl-2"><p>forward()前进功能</p></li><li class="lvl-2"><p>go()前进/后退</p></li></ul><h1>本地存储localStorage</h1><ul class="lvl-0"><li class="lvl-2"><p>在本地存储大量数据</p></li></ul><ol><li class="lvl-3"><p>数据存储在用户浏览器中</p></li><li class="lvl-3"><p>设置、读取方便、甚至页面刷新不丢失数据</p></li><li class="lvl-3"><p>容量较大，sessionStorage和localStorage约 5M 左右</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>localStorage</p></li><li class="lvl-2"><p>可以永久性的将数据存储在本地，除非手动删除</p></li><li class="lvl-2"><p>可以多窗口共享（同一浏览器）</p></li><li class="lvl-2"><p>以键值对的方存储</p></li><li class="lvl-2"><p>都加引号，并且只能存储字符串类型</p></li><li class="lvl-2"><p><code>localStorage.setItem(key,value)</code>存储/改数据</p></li><li class="lvl-2"><p><code>localStorage.getItem(key)</code>获取数据</p></li><li class="lvl-2"><p><code>localStorage.removeItem(key)</code>删除数据</p></li><li class="lvl-2"><p>sessionStorage</p></li><li class="lvl-2"><p>生命周期为关闭浏览器窗口</p></li><li class="lvl-2"><p>在同一个页面数据可以共享</p></li><li class="lvl-2"><p>以键值对的方式存储使用</p></li><li class="lvl-2"><p>用法跟localStorage基本相同</p></li></ul><h1>本地存储处理复杂数据类型</h1><ul class="lvl-0"><li class="lvl-2"><p>本地只能存储字符串，无法存储复杂数据类型</p></li><li class="lvl-2"><p>需要将复杂数据类型转换成JSON字符串，保存到本地</p></li><li class="lvl-2"><p><code>JSON.stringify(复杂数据类型)</code></p></li><li class="lvl-2"><p>JSON对象 属性和值有引号，同一是双引号</p></li><li class="lvl-2"><p><code>JSON.parse()</code>转换为对象</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 盒子模型</title>
    <link href="/2024/03/05/CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/03/05/CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1>盒子模型组成</h1><ul class="lvl-0"><li class="lvl-2">border 边框</li><li class="lvl-2">content 内容</li><li class="lvl-2">padding 内边距</li><li class="lvl-2">margin 外边距</li></ul><img src="/2024/03/05/CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/1.png" class="" title="这是图片的说明"><h1>边框 border</h1><p>border可以设置元素的边框。边框由三部分组成：边框宽度（粗细）边框样式 边框颜色</p><p>语法：<br><code>border : border-width || border-style || border-color</code></p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">border-width</td><td style="text-align:center">定义边框粗细，单位是px</td></tr><tr><td style="text-align:center">border-style</td><td style="text-align:center">边框的样式</td></tr><tr><td style="text-align:center">border-color</td><td style="text-align:center">边框颜色</td></tr></tbody></table><p>边框简写</p><p><code>border: 1px solid red;</code></p><p><strong>边框会影响盒子的实际大小</strong></p><h1>内边距 padding</h1><p>内边距即边框和内容之间的距离</p><p><code>padding : 10px</code></p><p><strong>padding会影响盒子实际大小</strong></p><p>如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子</p><p>如果保证盒子和效果图大小一致，则让width/height减去多出来的内边距大小即可</p><h1>外边距 margin</h1><p>margin控制盒子与盒子之间的距离</p><p><code>margin: 10px</code></p><p>典型应用：块级盒子水平居中</p><ul class="lvl-0"><li class="lvl-2"><p>盒子必须有宽度</p></li><li class="lvl-2"><p>盒子左右的外边距都为auto</p></li><li class="lvl-2"><p><code>margin: 0 auto,</code>即可实现</p></li></ul><p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。</p><p>当上下相邻的两个块元素(兄弟关系)相遇时，如果上面的元素有下外边距 margin-bottom ，下面的元素有上外边距 margin-top 则他们的垂直边距不是两个margin之和，而是两个值中的较大者，这种现象称为相邻块元素垂直外边距的合并。</p><p>解决办法：尽量只给一个盒子添加margin</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中的数组与字符串</title>
    <link href="/2024/03/05/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2024/03/05/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1>字符串</h1><p>字符串是一种基本数据类型</p><h2 id="获取字符串长度的length属性">获取字符串长度的length属性</h2><p>使用字符串的length属性可以查看当前字符串中字符的数量，双字符也会按照单字符来计算</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">str.<span class="hljs-property">length</span><br></code></pre></td></tr></table></figure><h2 id="字符串拼接-concat方法">字符串拼接 concat方法</h2><p>concat方法用于连接（合并/拼接）字符串，使用方法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">let</span> str2 = str.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;qwq&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2);<br></code></pre></td></tr></table></figure><p>字符串也可以使用加号运算符来拼接（常用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello&quot;</span>+<span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br></code></pre></td></tr></table></figure><h2 id="字符串切片方法-slice">字符串切片方法 slice</h2><p>切片方法，顾名思义，就是将字符串切成某一段的一片</p><p>它接受两个参数，第一个参数是开始的位置（必需），第二个参数是结束的位置</p><p>当传入负数时，按照从末尾开始算，-1表示倒数第一位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;一二三四五六七八&quot;</span>;<br><span class="hljs-keyword">let</span> strSplice = str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strSplice);<span class="hljs-comment">//一二三四五六</span><br></code></pre></td></tr></table></figure><h2 id="删除左右空格的trim方法">删除左右空格的trim方法</h2><p><code>trim</code>方法会返回一个新字符串，删除了左右的所有空格<br><strong>实际开发中会用到这个方法进行用户输入数据的处理</strong></p><h2 id="将字符串打碎成数组的split方法">将字符串打碎成数组的split方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;一二三四五六七八&quot;</span>;<br><span class="hljs-keyword">let</span> engStr = <span class="hljs-string">&quot;hello world you qwq&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>));<span class="hljs-comment">//&#x27;一&#x27;, &#x27;二&#x27;, &#x27;三&#x27;, &#x27;四&#x27;, &#x27;五&#x27;, &#x27;六&#x27;, &#x27;七&#x27;, &#x27;八&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(engStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>));<span class="hljs-comment">//&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;you&#x27;, &#x27;qwq&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="字符串的大小写转换方法-toLowCase-toUpperCase">字符串的大小写转换方法 toLowCase toUpperCase</h2><p>返回一个新字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sentence = <span class="hljs-string">&#x27;The quick brown fox jumps over the lazy dog.&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sentence.<span class="hljs-title function_">toUpperCase</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sentence.<span class="hljs-title function_">toLowCase</span>());<br></code></pre></td></tr></table></figure><h1>数组</h1><p>数组是一种复合数据类型，在数组中可以存储多个不同类型的数据</p><p>数据中存储的是有序的数据，对象存储的是无序的数据，数组中每个数都有一个唯一的索引</p><ul class="lvl-0"><li class="lvl-2"><p>索引是一组大于等于0的整数</p></li><li class="lvl-2"><p>创建数组</p><ul class="lvl-2"><li class="lvl-4">可以通过Array()，也可以通过数组字面量来创建数组</li></ul></li><li class="lvl-2"><p>向数组中添加元素</p><ul class="lvl-2"><li class="lvl-4"><code>数组[索引] = 元素</code></li></ul></li><li class="lvl-2"><p>length属性</p><ul class="lvl-2"><li class="lvl-4">获取数组中元素的数量，实际值为数组索引+1，length值可以修改，可以使用length向数组末尾添加元素</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>;<br><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<span class="hljs-comment">//数组字面量</span><br><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">22</span>;<br><br><span class="hljs-title function_">typeof</span>(arr)<span class="hljs-comment">//object</span><br><br>arr2.<span class="hljs-property">length</span> <span class="hljs-comment">//5</span><br><br>arr[arr.<span class="hljs-property">length</span>] = <span class="hljs-number">5</span> <span class="hljs-comment">//末尾添加</span><br></code></pre></td></tr></table></figure><h2 id="数组的迭代">数组的迭代</h2><p>JS中的数组有自己的迭代方式，不需要我们手动使用for循环遍历</p><ul class="lvl-0"><li class="lvl-2"><p>forEach方法：</p></li></ul><p><code>forEach()</code>方法没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;);<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>map方法</p></li></ul><p><code>map</code>方法是带有返回值的方法，并且<code>map</code>方法比<code>forEach()</code>要快，他会返回一个新的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">let</span> arrNew = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item + <span class="hljs-number">1</span>;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//1，2，3，4，5，6</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrNew);<span class="hljs-comment">//2，3，4，5，6，7</span><br></code></pre></td></tr></table></figure><h2 id="数组中查找某个元素的位置indexOf">数组中查找某个元素的位置indexOf</h2><p><code>indexOf(item，start)</code>方法可以返回数组中某个指定的元素位置。该方法将从头到尾地检索数组，看它是否含有对应的元素，开始检索的位置在数组 start 处或数组的开头（没有指定 start 参数时）。如果找到一个 item，则返回 item 的第一次出现的位置。如果在数组中没找到指定元素则返回 -1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];<br><span class="hljs-keyword">let</span> index = fruits.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;Apple&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index);<br><br></code></pre></td></tr></table></figure><h2 id="数组的过滤方法filter">数组的过滤方法filter</h2><p><code>fliter</code>方法用于对数组进行过滤，他会<strong>创建一个新数组</strong>，新数组中的元素是通过检查数组中符合条件的所有元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-keyword">var</span> result = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) &#123;<br>    <span class="hljs-keyword">return</span> number &gt; <span class="hljs-number">3</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><h2 id="数组转换成字符串方法join">数组转换成字符串方法join</h2><p><code>join()</code>可以将一个数组中的元素连接成一个字符串，参数是我们指定的一个字符作为连接符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>]<br><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">//aabb</span><br><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;@&quot;</span>)<span class="hljs-comment">//aa@bb</span><br></code></pre></td></tr></table></figure><h2 id="截取数组方法slice">截取数组方法slice()</h2><p>参数：截取的起始位置(包括)，截取的结束位置(不包括)</p><p>第二个参数可以省略，如果省略则一直截到最后</p><p>索引可以写负值</p><ul class="lvl-0"><li class="lvl-2"><p>如果两个参数全部省略，则可以对数组进行浅拷贝</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">arr = [<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Andy&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>]<br><br>result = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">//&quot;Tom&quot;,&quot;Andy&quot;</span><br></code></pre></td></tr></table></figure><h1>浅拷贝和深拷贝</h1><h2 id="浅拷贝">浅拷贝</h2><ul class="lvl-0"><li class="lvl-2"><p>通常对对象的拷贝都是浅拷贝</p></li><li class="lvl-2"><p>浅拷贝顾名思义，只对对象的浅层进行拷贝</p></li><li class="lvl-2"><p>如果对象中存储的数据是原始值，那么拷贝的深浅不重要</p></li><li class="lvl-2"><p>浅拷贝只会对对象本身进行复制，不会复制对象中的属性，或元素</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Tom&quot;</span>&#125;,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;bob&quot;</span>&#125;]<br><span class="hljs-keyword">const</span> arr2 = arr.<span class="hljs-title function_">slice</span>()<span class="hljs-comment">//浅拷贝</span><br></code></pre></td></tr></table></figure><h2 id="深拷贝">深拷贝</h2><ul class="lvl-0"><li class="lvl-2"><p>不仅复制对象本身，还复制对象中的属性和元素</p></li><li class="lvl-2"><p>通常情况下不使用深拷贝</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr3 = <span class="hljs-title function_">structuredClone</span>(arr)<span class="hljs-comment">//深拷贝</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中的面向对象编程</title>
    <link href="/2024/03/05/JavaScript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/03/05/JavaScript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1>类</h1><ol><li class="lvl-3">类是对象模版，可以将对象中的属性和方法直接定义在类中，定义后就可以直接通过类来创建对象</li><li class="lvl-3">通过同一个类创建的对象，我们称之为同对象，可以通过<code>instanceof</code>来检查一个对象是否是某个类创建，则我们称该对象是这个类的实例</li><li class="lvl-3">通过类创建对象的语法<code>new 类()</code></li></ol><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><span class="hljs-comment">//person类专门用来创建人的对象</span><br>&#123;<br><br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span> <span class="hljs-comment">//p1是person的实例</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h2 id="属性">属性</h2><p>类是创建对象的模板，要创建第一件事就是定义类</p><p>使用<code>static</code>声明的属性为静态属性，不可以通过实例访问，只能通过类访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    name = <span class="hljs-string">&#x27;Tom&#x27;</span><span class="hljs-comment">//Person的实例属性name</span><br>    age = <span class="hljs-number">18</span><span class="hljs-comment">//实例属性只能通过实例访问 p1.age</span><br>    <span class="hljs-keyword">static</span> test = <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-comment">//静态属性只能通过类访问 Person.test</span><br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br></code></pre></td></tr></table></figure><h2 id="构造函数">构造函数</h2><p>当我们在类中直接指定值的时候，意味着我们创建的所有对象都是这个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Perosn</span>&#123;<br>name = <span class="hljs-string">&quot;Tom&quot;</span><br>age = <span class="hljs-number">18</span><br>gender = <span class="hljs-string">&#x27;男&#x27;</span><br><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想自己给类的属性赋值怎么办？</p><p>此时我们可以使用一个特殊的方法——构造函数(constructor)</p><p>构造函数会在我们调用类创建对象时执行，我们可以在构造函数中为属性赋值，在构造函数中，this表示当前创建的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span><br>&#123;<br>    name<br>    age<br>    gender<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age,gender</span>)<br>    &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>封装</h1><ul class="lvl-0"><li class="lvl-2"><p>封装、继承、多态是面向对象编程三大特性</p></li></ul><p>对象就是一个用来存储不同属性的容器，对象不仅负责属性，还要负责数据的安全，直接添加到对象中的属性并不安全，因为他们可以被任意修改</p><p>如何保证数据安全？</p><ol><li class="lvl-3"><p>私有化数据</p><ul class="lvl-2"><li class="lvl-5">将需要保护的数据设置为私有，只能在类内使用，私有属性必须事先说明</li></ul></li><li class="lvl-3"><p>提供类内公有方法来间接读取类内私有属性，相当于提供一个接口，该方法的好处是不仅可以控制属性的读写权限还可以在方法中对属性值进行控制</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><br>#address = <span class="hljs-string">&#x27;Beijing&#x27;</span> <span class="hljs-comment">// 实例使用#开头就变成了私有属性 私有属性只能在类内部访问</span><br>#name;<br>#age;<br>#gender<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age,gender</span>)&#123;<br><span class="hljs-variable language_">this</span>.#name = name<br><span class="hljs-variable language_">this</span>.#age = age<br><span class="hljs-variable language_">this</span>.#gender = gender<br>&#125;<br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.#name)<br>&#125;<br><br><span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//getter方法，用来读取属性</span><br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name<br>&#125;<br><span class="hljs-title function_">setAge</span>(<span class="hljs-params">age</span>)&#123;<span class="hljs-comment">//setter方法，用来设置属性</span><br><span class="hljs-keyword">if</span>(age&gt;=<span class="hljs-number">0</span>)&#123;<br><span class="hljs-variable language_">this</span>.#age = age<br>&#125;<br>&#125;<br><span class="hljs-keyword">get</span> <span class="hljs-title function_">gender</span>()&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#gender<br>&#125;<br>&#125;<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Perosn</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;男&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">gender</span>())<br><br></code></pre></td></tr></table></figure><h1>多态</h1><ul class="lvl-0"><li class="lvl-2"><p>在Js中不会检查参数的类型，这就意味着任何数据都可以作为参数传递</p></li><li class="lvl-2"><p>要调用某个函数，无需指定的类型，只要对象满足某些条件即可</p></li><li class="lvl-2"><p>多态为我们提供了灵活性</p></li></ul><h1>继承</h1><p>通过<code>extends</code>关键字来完成继承</p><p>简单来说，当一个类继承另一个类时，就相当于将另一个类复制到了代码中</p><p>在继承中，被继承的类称为<strong>父类</strong>，继承的类称为<strong>子类</strong></p><p>通过继承可以大大减少重复的代码，并且可以在不修改一个类的前提下对其进行扩展</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> 子类 <span class="hljs-keyword">extends</span> 父类<br></code></pre></td></tr></table></figure><p>在子类中，可以通过创建同名方法来重写父类的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;动物在叫&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span>&#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name ,age</span>)&#123;<br><span class="hljs-comment">//重新构造函数时，构造函数的第一行代码必须为super()</span><br><span class="hljs-variable language_">super</span>(name)<span class="hljs-comment">//this.name = name</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//调用父类的sayHello</span><br><span class="hljs-comment">// super.sayHello//动物在叫</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;喵喵喵&quot;</span>)<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;汤姆&quot;</span>,<span class="hljs-number">5</span>)<br><br>cat.<span class="hljs-title function_">sayHello</span>()<span class="hljs-comment">//喵喵喵</span><br></code></pre></td></tr></table></figure><p>注意，如果你想调用父类中的方法活着构造函数，你需要用<code>super()</code>来调用父类的属性</p><h1>对象的结构</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>name = <span class="hljs-string">&#x27;Tom&#x27;</span><br>age = <span class="hljs-number">18</span><br><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello,&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)<br></code></pre></td></tr></table></figure><p>如果你打印出这个对象，你会发现可以看见里面的name，age但是看不见sayHello方法</p><p>对象中存储属性的区域实际上有两个</p><ol><li class="lvl-3"><p>对象自身</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>直接通过对象添加的属性，位于对象自身中</p></li><li class="lvl-2"><p>在类中通过 x=y 添加的属性位于对象自身中</p></li></ul><ol start="2"><li class="lvl-3"><p>原型对象</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>在对象中还有一些内容会存储到其他的位置</p></li><li class="lvl-2"><p>在对象中会有一个属性来存储原型对象， 这个属性叫做<code>__proto__</code>，原型对象也负责为对象存储属性</p></li><li class="lvl-2"><p>当我们访问对象中的属性时，会优先访问对象自身的属性，如果找不到，则去原型对象中去找</p></li><li class="lvl-2"><p>会添加到原型对象中的情况</p><ol><li class="lvl-5">在类中通过xxx(){}方式添加的方法，位于原型对象中</li><li class="lvl-5">主动向原型中添加属性或方法</li></ol></li></ul><h1>原型对象</h1><p>原型对象中的数据结构：</p><ol><li class="lvl-3"><p>对象中的数据（属性，方法等）</p></li><li class="lvl-3"><p>constructor（对象的构造函数）</p></li></ol><h2 id="原型链">原型链</h2><p>原型对象也有原型，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同，原型链最后指向NULL</p><p>读取对象属性时，优先在对象本身中寻找，如果对象中有，则使用，没有则去对象的原型中找，如果原型中有，则使用，没有则去原型的原型中去寻找，直到找到Object对象的原型，Object的原型没有原型（null），如果依然没有找到，返回Undefined。</p><p>区分作用域链和原型链</p><ul class="lvl-0"><li class="lvl-2"><p>作用域链，找变量的链，找不到会报错</p></li><li class="lvl-2"><p>原型链，是找属性的链，找不到会返回Undefined</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>name = <span class="hljs-string">&#x27;Tom&#x27;</span><br>age = <span class="hljs-number">18</span><br><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello,&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)<span class="hljs-comment">//可以看见name 和 age 看不见方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span>)<span class="hljs-comment">//原型对象,不建议这么访问</span><br><br>concole.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(p))<span class="hljs-comment">//安全访问</span><br></code></pre></td></tr></table></figure><h2 id="原型的作用">原型的作用</h2><ul class="lvl-0"><li class="lvl-2"><p>所有的同类型对象，他们的原型对象是一个，也就意味着原型链也是一个</p></li><li class="lvl-2"><p>原型的作用</p><ul class="lvl-2"><li class="lvl-4">相当于一个公共的区域，可以被所有的类访问。</li><li class="lvl-4">可以将一个该类实例中所有的公共属性(方法)统一存储到原型中，这样我们只需要创建一个属性，即可被所有实例访问</li><li class="lvl-4">JS中继承就是通过原型实现的</li><li class="lvl-4">继承时，子类的原型就是一个父类的实例。</li><li class="lvl-4">在对象中有些属性是对象独有的，像属性，每个对象都应该有自己值，但是有些值对于每个对象来说都是一样的，像各种方法，对于一样的值没有必要重复的创建</li></ul><h2 id="修改原型">修改原型</h2><p>大部分情况下不需要修改原型</p><p><strong>注意！</strong></p><p>千万不要通过类的实例去修改原型！</p><ol><li class="lvl-5"><p>通过一个对象影响所有同类对象，这样不合适</p></li><li class="lvl-5"><p>修改原型需要先创建实例，繁琐</p></li><li class="lvl-5"><p>危险</p></li></ol></li><li class="lvl-2"><p>处理通过<code>__proto__</code>能访问对象的原型外，还可以通过类的prototype属性来访问实例的原型</p></li></ul><p>好处</p><ol><li class="lvl-3"><p>修改一个就是修改所有实例的原型</p></li><li class="lvl-3"><p>无需创建实例即可完成对类的修改</p></li></ol><p>原则</p><ol><li class="lvl-3"><p>尽量不要改</p></li><li class="lvl-3"><p>通过类.prototype来改</p></li><li class="lvl-3"><p>最好不要直接给prototype赋值</p></li></ol><h1>instanceof 和 hasOwn</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span>&#123;&#125;<br><br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>)<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>)<span class="hljs-comment">//true`</span><br></code></pre></td></tr></table></figure><p><code>instanceof</code>用来检查一个对象是否是一个类的实例</p><ul class="lvl-0"><li class="lvl-2"><p>检查的是对象的原型链上是否有改类实例，只要有，返回true</p></li><li class="lvl-2"><p>dog -&gt; Animal的实例 -&gt; Object实例 -&gt; Object原型</p></li><li class="lvl-2"><p><code>Object</code>是所有对象的原型，所以任何对象和<code>Object</code>进行<code>instanceof</code>运算都会返回true</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>name = <span class="hljs-string">&#x27;Tom&#x27;</span><br>age = <span class="hljs-number">18</span><br><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name in p&quot;</span>)<span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;sayHello in p&quot;</span>)<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;sayHello&quot;</span>))<span class="hljs-comment">//flase</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(p,<span class="hljs-string">&quot;sayHello&quot;</span>))<span class="hljs-comment">//flase</span><br></code></pre></td></tr></table></figure><p>使用<code>in</code>运算符检查属性时，无论属性在对象自身还是在原型中，都返回true</p><ul class="lvl-0"><li class="lvl-2"><p><code>对象.hasOwnProperty(属性名)</code></p><ul class="lvl-2"><li class="lvl-6">用来检查一个对象自身是否含有某个属性</li></ul></li><li class="lvl-2"><p><code>Object.hasOwn(对象,&quot;属性名&quot;)</code></p><ul class="lvl-2"><li class="lvl-6">用来检查一个对象自身是否含有某个属性</li></ul></li></ul><h1>new 运算符</h1><ul class="lvl-0"><li class="lvl-2"><p>new运算符是创建对象时要用到的运算符</p></li></ul><p>使用new的时候发生呢干了什么？</p><p>当我们用new去调用一个函数，这个函数将会作为构造函数调用</p><ol><li class="lvl-3"><p>创建一个普通的JS对象（Object{ }），为了方便，称其为新对象</p></li><li class="lvl-3"><p>指定新对象的原型指定为构造函数的prototype的属性</p></li><li class="lvl-3"><p>使用实参来执行构造函数，并且将我们的新对象设置为函数中的this</p></li><li class="lvl-3"><p>如果构造函数返回的是一个非原始值，则该值会作为new运算的返回值返回，如果返回的是原始值或者没有返回值，则新的对象作为返回值（通常不要返回值）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中的对象</title>
    <link href="/2024/03/04/JavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/03/04/JavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1>对象基本操作</h1><ul class="lvl-0"><li class="lvl-2">如果我们需要在程序中表示一个人的信息，使用原始值无法表现出“一个整体的”的特点，对象能够完成这个任务</li><li class="lvl-2">对象是JS中的一个复合数据类型，它相当于一个容器，在对象中可以存储各种不同类型的数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span> <span class="hljs-comment">//创建了一个新的对象</span><br><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span> <span class="hljs-comment">//简化版，省略了new</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2">对象中可以存储多个类型的数据，对象里存储的数据被称为属性</li><li class="lvl-2">向对象中添加属性：对象.属性名 = 属性值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Tom&quot;</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br>obj.<span class="hljs-property">gender</span> = <span class="hljs-string">&quot;男&quot;</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2">读取对象中的属性对象.属性名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>)<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2">修改对象中的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2">删除对象中的属性</li><li class="lvl-2">如果读取的是一个对象中没有的属性，会输出Undefined</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">delete</span> obj.<span class="hljs-property">name</span><br></code></pre></td></tr></table></figure><h1>对象的属性</h1><h2 id="属性名">属性名</h2><ul class="lvl-0"><li class="lvl-2"><p>通常属性名就是一个字符串，所以属性名可以是任何值，没有特殊要求，但是太特殊会不能直接使用，还是强烈建议属性名也按照标识符的规范</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">if</span> = <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-comment">//合法</span><br>obj.<span class="hljs-property">let</span> = <span class="hljs-string">&#x27;666&#x27;</span> <span class="hljs-comment">//合法</span><br>obj<span class="hljs-number">.1234</span> = <span class="hljs-string">&#x27;2334&#x27;</span> <span class="hljs-comment">//不合法！</span><br>obj.[<span class="hljs-string">&quot; 123@**!! &quot;</span>] = <span class="hljs-string">&quot;123&quot;</span> <span class="hljs-comment">//合法</span><br><span class="hljs-comment">//避免使用这些属性名</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>也可以用符号作为属性名，使用symbol作为属性名</p></li><li class="lvl-2"><p>获取这种属性时也需要通过symbol获取</p></li><li class="lvl-2"><p>使用symbol获取的属性，通常是不希望被外界访问的属性</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> mySymbol = <span class="hljs-title class_">Symbol</span>()<br>obj[symbol] = <span class="hljs-string">&quot;通过symbol添加的属性&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[mySymbol])<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>使用[]操作属性时，可以使用变量</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;address&#x27;</span><br>obj[str] = <span class="hljs-string">&#x27;翻斗大街&#x27;</span><span class="hljs-comment">//等价于obj[&quot;address&quot;] = &#x27;翻斗大街&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="属性值">属性值</h2><ul class="lvl-0"><li class="lvl-2"><p>对象的属性值可以是任意的数据类型，也可以是<strong>一个对象</strong></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">f</span> = <span class="hljs-title class_">Object</span>()<br>obj.<span class="hljs-property">f</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Bob&#x27;</span><br>obj.<span class="hljs-property">f</span>.<span class="hljs-property">age</span> = <span class="hljs-number">28</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">f</span>.<span class="hljs-property">name</span>)<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>in</code>运算符</p></li><li class="lvl-2"><p>检查对象是否有某个属性，返回true或false</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name&quot;</span><span class="hljs-keyword">in</span> obj)<br></code></pre></td></tr></table></figure><h1>对象字面量</h1><p>可以使用字面量的方式创建对象可以直接使用{}来创建对象可以直接向对象里添加属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,[<span class="hljs-string">&quot;gender&quot;</span>]:<span class="hljs-string">&#x27;男&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h1>枚举对象中的属性</h1><ul class="lvl-0"><li class="lvl-2"><p>枚举属性：将对象中的所有的属性全部获取</p></li><li class="lvl-2"><p><code>for-in</code>语句</p></li><li class="lvl-2"><p><code>for(let propName in 对象)&#123;...&#125;</code></p></li><li class="lvl-2"><p>有几个属性运行几次，并不是所有的属性都可以枚举，比如用符号添加的属性</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj =&#123;<br>name=<span class="hljs-string">&#x27;Tom&#x27;</span>,<br>age = <span class="hljs-number">18</span>,<br>gender = <span class="hljs-string">&#x27;男&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> propName <span class="hljs-keyword">in</span> obj)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//打印三次</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(propName, obj[propName])<span class="hljs-comment">//获取属性名以及属性值</span><br>&#125;<br></code></pre></td></tr></table></figure><h1>可变类型</h1><ul class="lvl-0"><li class="lvl-2"><p>原始值都属于不可变类型，一旦创建就无法修改，在内存中不会创建重复的原始值</p></li><li class="lvl-2"><p>对象是一种可变类型，对象创建完成后，可以任意的添加修改删除对象中的属性</p></li><li class="lvl-2"><p><strong>注意</strong>：如果有两个变量同时指向一个对象，同一个变量修改对象时也会产生影响</p></li><li class="lvl-2"><p>当两个对象进行比较时，实际比较的是内存地址</p></li></ul><h1>变量和对象</h1><ul class="lvl-0"><li class="lvl-2"><p>修改对象</p></li></ul><p>修改对象时，如果有其他变量指向该对象，则所有指向改对象的变量都会受到影响</p><ul class="lvl-0"><li class="lvl-2"><p>修改变量</p></li></ul><p>修改变量时，只会影响当前的变量</p><ul class="lvl-0"><li class="lvl-2"><p>在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度，所以通常情况下，声明存储对象的变量时会使用const</p></li></ul><h1>方法</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;<br><br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Tom&#x27;</span><br>obj.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br><span class="hljs-comment">//函数也可以称为一个对象的属性</span><br>obj.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello!&#x27;</span>)<br>&#125;<br>obj.<span class="hljs-title function_">sayHello</span>()<span class="hljs-comment">//调用obj的sayHello方法</span><br></code></pre></td></tr></table></figure><p>方法</p><ul class="lvl-0"><li class="lvl-2"><p>放一个对象的属性指向一个函数，那么我们就称这个函数是该对象的方法，调用函数就被称为调节对象的方法。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript函数基础</title>
    <link href="/2024/03/04/JavaScript%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/04/JavaScript%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1>定义函数</h1><h2 id="函数声明">函数声明</h2><p>一个函数定义（也称为函数声明，或者函数语句）由<code>function</code>关键字，并跟随以下部分组成</p><ul class="lvl-0"><li class="lvl-2">函数名称</li><li class="lvl-2">函数参数列表</li><li class="lvl-2">定义函数的JavaScript语句</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">number</span>)&#123;<br>    <span class="hljs-keyword">return</span> number + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>typeof</code>检测类型为function</p></li></ul><p>参数本质上是按照值传递给函数的——因此即使函数体的代码为传递函数的参数赋了新值，这个改变也不会反映到全局或调用该函数的代码中。</p><p>如果你将对象作为参数传递，而参数改变了这个对象的属性，这样的改变对函数外部是可见的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">theObject</span>) &#123;<br>  theObject.<span class="hljs-property">make</span> = <span class="hljs-string">&quot;Toyota&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> mycar = &#123;<br>  <span class="hljs-attr">make</span>: <span class="hljs-string">&quot;Honda&quot;</span>,<br>  <span class="hljs-attr">model</span>: <span class="hljs-string">&quot;Accord&quot;</span>,<br>  <span class="hljs-attr">year</span>: <span class="hljs-number">1998</span>,<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mycar.<span class="hljs-property">make</span>); <span class="hljs-comment">// &quot;Honda&quot;</span><br><span class="hljs-title function_">myFunc</span>(mycar);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mycar.<span class="hljs-property">make</span>); <span class="hljs-comment">// &quot;Toyota&quot;</span><br><br></code></pre></td></tr></table></figure><p>如果你将数组作为参数传递，而参数改变了这个数组的值，这样的改变对函数外部也同样可见</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunc</span>(<span class="hljs-params">theArr</span>) &#123;<br>  theArr[<span class="hljs-number">0</span>] = <span class="hljs-number">30</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">45</span>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 45</span><br><span class="hljs-title function_">myFunc</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 30</span><br><br></code></pre></td></tr></table></figure><h2 id="函数表达式">函数表达式</h2><p>由函数表达式创建的函数是<strong>匿名</strong>的，它不必有一个名称,例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> square = <span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>)&#123;<br>    <span class="hljs-keyword">return</span> number*number;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以为函数表达式提供名称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> factorial = <span class="hljs-keyword">function</span> <span class="hljs-title function_">fac</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : n * <span class="hljs-title function_">fac</span>(n - <span class="hljs-number">1</span>);<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>我们也可以将函数作为函数的参数,函数也是对象的一种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params">a</span>)&#123;<br><span class="hljs-title function_">a</span>()<br>&#125;<br><br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是fn2&quot;</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>(fn2)<span class="hljs-comment">//我是fn2</span><br></code></pre></td></tr></table></figure><h1>函数参数</h1><ul class="lvl-0"><li class="lvl-2"><p>在定义函数中，可以在函数中指定数量不等的参数</p></li><li class="lvl-2"><p>在函数中定义形参相当于在函数内部生成了一个没有赋值的变量</p></li><li class="lvl-2"><p>在调用函数时候，可以在函数的()内传递数量不等的实参</p></li><li class="lvl-2"><p>实参会赋值给对应的形参</p></li><li class="lvl-2"><p>参数</p><ol><li class="lvl-5">如果实参和形参数量相同，则对应的实参复制给对应的形参</li><li class="lvl-5">如果实参多于形参，则多余的实参不会使用</li><li class="lvl-5">如果形参多于实参 ，则多余的形参为Undefined</li></ol></li><li class="lvl-2"><p>任何值都可以作为参数，<strong>注意：函数不会检查类型</strong></p></li></ul><h2 id="函数重载">函数重载</h2><ul class="lvl-0"><li class="lvl-2"><p>函数通过参数的个数和类型不同来创建不同的函数签名，通过调用函数时传入的参数个数和参数类型来进行命名参数的验证。</p></li><li class="lvl-2"><p>但是，在js后声明的同名函数会对前面声明的一个函数进行一个覆盖，所以JavaScript没有真正意义上的函数重载</p></li></ul><h2 id="类数组arguments对象">类数组arguments对象</h2><ul class="lvl-0"><li class="lvl-2"><p>如果一个函数传递了三个参数，你可以以如下方式引用他们</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]<br><span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]<br><span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h2 id="回调函数">回调函数</h2><pre><code class="hljs">回调函数是一个函数，将会在另一个函数完成执行后立即执行。回调函数是一个作为参数传给另一个 JavaScript 函数的函数。这个回调函数会在传给的函数内部执行。</code></pre><h1>函数提升</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-comment">//Undefined</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="变量的提升">变量的提升</h2><ul class="lvl-0"><li class="lvl-2"><p>使用var声明的变量，它会在所有代码执行前被声明但是<strong>不会被赋值</strong></p><ul class="lvl-2"><li class="lvl-4">我们可以在变量声明前就访问变量</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fn</span>()<span class="hljs-comment">//可以成功执行</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;111&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数的提升">函数的提升</h2><ul class="lvl-0"><li class="lvl-2"><p>使用**函数声明（function开头）**创建的函数，会在其他代码执行前被创建</p></li><li class="lvl-2"><p>我们可以在函数声明前调用函数</p></li><li class="lvl-2"><p>JavaScript解释器会将整个函数声明提升到当前作用域的顶部</p></li></ul><h2 id="let声明的变量">let声明的变量</h2><ul class="lvl-0"><li class="lvl-2"><p>let声明的变量实际上也会提升，但是在赋值之前解释器禁止访问该变量</p></li></ul><h1>函数作用域</h1><p>在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的作用域内定义。相对应的，一个函数可以访问定义在其范围内的任何变量和函数</p><ul class="lvl-0"><li class="lvl-2"><p>函数作用域在函数调用时产生，调用结束后销毁</p></li><li class="lvl-2"><p>函数每次调用都会产生一个全新的函数作用域</p></li><li class="lvl-2"><p>在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问</p></li></ul><h1>闭包</h1><p>闭包是 JavaScript 中最强大的特性之一。JavaScript 允许函数嵌套，并且内部函数具有定义在外部函数中的所有变量和函数（以及外部函数能访问的所有变量和函数）的完全访问权限。</p><p>但是，外部函数却不能访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一种封装。</p><p>此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数的生存周期将比内部函数执行的持续时间要长。当内部函数以某一种方式被任何一个外部函数之外的任何作用域访问时，就会创建闭包</p><p><strong>注意：使用闭包时需要注意许多陷阱！</strong></p><p>如果一个闭包的函数定义了一个和外部的某个变量名称相同的变量，那么这个闭包将无法引用外部作用域中的这个变量。（内部作用域的变量“覆盖”外部作用域，直至程序退出内部作用域。可以将其视作命名冲突。</p><h1>作用域链</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span><br>&#123;<br><span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;第一代码块中的a&quot;</span><br>&#123;<br><span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;第二代码块中的a&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-comment">//第二代码块中的a</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用域链</p><ul class="lvl-0"><li class="lvl-4"><p>当我们使用一个变量时，JavaScript解释器会优先在当前作用域中寻找变量，如果找到了则直接使用，如果没找到，则去上一层作用域中寻找，如果一直没找到，就会报错！</p></li></ul><h1>window对象</h1><ul class="lvl-0"><li class="lvl-2"><p>浏览器为我们提供了一个window对象，可以直接访问</p></li><li class="lvl-2"><p>window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作，除此之外，window对象还负责存储JS中的内置对象和浏览器的宿主对象</p></li><li class="lvl-2"><p>window对象的属性可以通过window对象访问，也可以直接访问</p></li><li class="lvl-2"><p>函数可以认为是window对象的方法</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-number">123</span>)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">console</span>.<span class="hljs-title function_">log</span>()<span class="hljs-comment">//window可省略</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span> = <span class="hljs-number">10</span><span class="hljs-comment">//向window中添加的属性会自动成为全局变量</span><br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>var用来声明变量，作用和let相同，但是var不具有块作用域</p><ul class="lvl-2"><li class="lvl-4">全局中使用var声明的变量，都会作为window对象的属性保存</li><li class="lvl-4">使用function声明的函数，都会作为window的方法保存</li><li class="lvl-4">使用let声明的变量不会存储在window<br>综合例子：</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-number">20</span> <span class="hljs-comment">//window.b = 20</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是fn&#x27;</span>)<br>&#125;<br><br><span class="hljs-title function_">fn</span>()<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">fn</span>()<br><br><span class="hljs-keyword">let</span> c = <span class="hljs-number">33</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">c</span>()<span class="hljs-comment">//Undefined</span><br><br><span class="hljs-keyword">let</span> c = <span class="hljs-number">33</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">c</span> = <span class="hljs-number">44</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c)<span class="hljs-comment">//33 首先在秘密的地方找</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//var d = 10 var虽然没有块作用域，但是有函数作用域</span><br>d = <span class="hljs-number">10</span><span class="hljs-comment">//在局部作用域中，如果没有使用var或者let声明变量，则变量自动称为window对象的属性也就是全局变量，不要这样！！</span><br>&#125;<br><br><span class="hljs-title function_">fn2</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d)<span class="hljs-comment">//可以访问</span><br></code></pre></td></tr></table></figure><h1>函数中的this</h1><ul class="lvl-0"><li class="lvl-2"><p>环境对象this</p></li><li class="lvl-2"><p>函数在执行时，JavaScript解释器每次都会传递一个隐含的参数，这个参数叫this</p></li><li class="lvl-2"><p>this会指向一个对象</p><ul class="lvl-2"><li class="lvl-4">this指向的对象会根据函数调用方式的不同而不同<ol><li class="lvl-7">以函数形式调用，this指向<code>window</code></li><li class="lvl-7">以方法的方式调用，this指向的是调用方法的对象</li><li class="lvl-7">谁调用指向谁例子：</li></ol></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<span class="hljs-comment">//this === window</span><br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span>&#125;<br><br>obj.<span class="hljs-property">test</span> = fn<br><br><span class="hljs-keyword">const</span> obj2 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Bob&#x27;</span>,<span class="hljs-attr">test</span>:fn&#125;<br><br><span class="hljs-title function_">fn</span>()<span class="hljs-comment">//window window.fn()</span><br>obj.<span class="hljs-title function_">test</span>()<span class="hljs-comment">//name:&#x27;Tom&#x27;</span><br>obj2.<span class="hljs-title function_">test</span>()<span class="hljs-comment">//name:&#x27;Bob&#x27;,test:fn</span><br></code></pre></td></tr></table></figure><h1>箭头函数</h1><p>箭头函数表达式相比函数表达式有着更简洁的语法。箭头函数总是匿名的</p><p>有两个因素会影响箭头函数的引入：更简洁的函数和<code>this</code>的无绑定性</p><p>定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> 变量 = <span class="hljs-function">() =&gt;</span>&#123;<br>    ...<br>&#125;<br><span class="hljs-keyword">const</span> 变量 = <span class="hljs-function">() =&gt;</span> ...<br></code></pre></td></tr></table></figure><h2 id="箭头函数参数和返回值">箭头函数参数和返回值</h2><p>箭头函数只有一个参数时，可以省略括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn2</span> = a =&gt;&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数的返回值可以写在箭头后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> a+b<br>&#125;<br>简化为<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a,b</span>) =&gt; a+b<br></code></pre></td></tr></table></figure><p>如果直接在箭头后设置对象字面量为返回值时，对象字面量必须使用（）括起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; (&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;TOM&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h2 id="箭头函数的this">箭头函数的this</h2><ul class="lvl-0"><li class="lvl-2"><p>箭头函数没有自己的this，它的this由外层作用域决定，和他的this无关举例说明：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fn --&gt;&quot;</span>,<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn2</span> = (<span class="hljs-params"></span>) =&gt; (<span class="hljs-string">&quot;fn2 --&gt;&quot;</span>,<span class="hljs-variable language_">this</span>)<br><br><span class="hljs-title function_">fn</span>()<span class="hljs-comment">//--&gt;window</span><br><span class="hljs-title function_">fn2</span>()<span class="hljs-comment">//--window</span><br><br><span class="hljs-keyword">const</span> obj=&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span>,<br><span class="hljs-attr">fn</span>:fn,<br>fn2,<span class="hljs-comment">//属性名和属性值相同可以省略</span><br>sayHello<span class="hljs-comment">/*:function(可以省略)*/</span>()&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">t</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;t--&gt;&quot;</span>,<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-title function_">t</span>()<span class="hljs-comment">//--&gt;window 由函数调用</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">t2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;t2 --&gt;&quot;</span>,<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-title function_">t2</span>()<span class="hljs-comment">//--&gt;obj 箭头函数this由外层作用域决定</span><br>&#125;<br>&#125;<br>obj.<span class="hljs-title function_">fn</span>()<span class="hljs-comment">//--&gt;obj</span><br>obj.<span class="hljs-title function_">fn2</span>()<span class="hljs-comment">//--&gt;window</span><br></code></pre></td></tr></table></figure><h1>立即执行函数</h1><p>在开发中应该尽量减少直接在全局作用域中编写代码！</p><p>我们的代码要尽量编写在局部作用域中，如果使用let声明的变量，可以利用{}来创建块作用域</p><p>立即执行函数是一个匿名的函数，并且只会调用一次</p><p>可以利用立即执行函数来创建一个一次性的函数作用域，避免变量冲突</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span><br>&#125;() );<span class="hljs-comment">//两个在一起要加分号</span><br><br>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span><br>&#125;() )<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础</title>
    <link href="/2024/03/03/JavaScript%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/03/JavaScript%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1>Javascript简介</h1><ul class="lvl-0"><li class="lvl-2">JavaScript 是一门跨平台、面向对象的脚本语言，它能使网页可交互（例如拥有复杂的动画，可点击的按钮，通俗的菜单等）。另外还有高级的服务端 Javascript 版本，例如 Node.js，它可以让你在网页上添加更多功能，不仅仅是下载文件（例如在多台电脑之间的协同合作）。在宿主环境（例如 web 浏览器）中，JavaScript 能够通过其所连接的环境提供的编程接口进行控制</li><li class="lvl-2">JavaScript是一种动态弱类型语言</li><li class="lvl-2">如今，JavaScript 已经成为了与 HTML/CSS 完全集成的，使用最广泛的浏览器语言</li></ul><h1>变量</h1><p>我们可以用 var ，let 或 const 声明变量来存储数据</p><ul class="lvl-0"><li class="lvl-2"><p>let - 现代的变量声明方式</p></li><li class="lvl-2"><p>var - 老旧的变量声明方式，一般情况下，我们不会再使用它。</p></li><li class="lvl-2"><p>const - 类似于let，但是变量的值无法被修改</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> a;<br><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h1>JavaScript标识符</h1><p>所有JavaScript变量必须以<strong>唯一</strong>的名称为标识</p><p>这些唯一的名称称为<strong>标识符</strong></p><p>构造变量名称的通用规则是：</p><ol><li class="lvl-3"><p>名称可以包含字母，数字，下划线，和美元符号$</p></li><li class="lvl-3"><p>名称也可以以字母，$ 和 _ 开头</p></li><li class="lvl-3"><p>名称对大小写敏感（y和Y是两个变量）</p></li><li class="lvl-3"><p>保留字无法用做变量名称</p></li></ol><h1>数据类型</h1><p>JavaScript 有八种基本的数据类型（七种基本数据类型和一个复杂数据类型）</p><ul class="lvl-0"><li class="lvl-2"><p>Number</p><ul class="lvl-2"><li class="lvl-6">用于任何类型的数字：整数或浮点数，范围在±（253-1）范围内的整数</li></ul></li><li class="lvl-2"><p>BigInt</p><ul class="lvl-2"><li class="lvl-4">用于任意长度的整数</li></ul></li><li class="lvl-2"><p>String</p><ul class="lvl-2"><li class="lvl-4">用于字符串，一个字符串可以包含0个或多个字符类型</li></ul></li><li class="lvl-2"><p>Boolean</p><ul class="lvl-2"><li class="lvl-4">用于true 和 false</li><li class="lvl-4">true不一定等于1，false不一定等于0</li></ul></li><li class="lvl-2"><p>Null</p><ul class="lvl-2"><li class="lvl-4">表示未知值，只有一个null值的独立类型</li><li class="lvl-4">null表示空对象指针</li></ul></li><li class="lvl-2"><p>Undefined</p><ul class="lvl-2"><li class="lvl-4">用于还没有定义的值——只有一个undefined值的独立类型</li><li class="lvl-4">在使用var声明变量但是没有初始化时，这个变量就是undefined</li></ul></li><li class="lvl-2"><p>Symbol</p><ul class="lvl-2"><li class="lvl-4">用于唯一的标识符</li></ul></li><li class="lvl-2"><p>Object</p><ul class="lvl-2"><li class="lvl-4">用于更复杂的数据结构，比如function、array、date</li></ul></li></ul><p><strong>我们可以使用typeof运算符查看数据类型</strong></p><p><code>typeof x</code>或者<code>typeof(x)</code></p><ul class="lvl-0"><li class="lvl-2"><p>会返回字符串类型，例如“string”<br><code>typeof null</code>会返回“object”——这是js的错误，实际上它不是object</p></li></ul><h1>值的比较</h1><ul class="lvl-0"><li class="lvl-2"><p>运算符</p></li></ul><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:center">比较两个操作数的值是否相等</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">比较两个操作数的值是否不相等</td></tr><tr><td style="text-align:center">===</td><td style="text-align:center">比较两个操作数的值是否相等，同时检查类型是否相同</td></tr><tr><td style="text-align:center">!==</td><td style="text-align:center">比较两个操作数的值是否不相等，同时检查类型是否不相同</td></tr></tbody></table><p><strong>能不用<mark>就不用</mark>，尽量使用===来确保不会出现不可预料的错误</strong></p><h1>类型转换</h1><ol><li class="lvl-3"><p>显式类型转换</p><ol><li class="lvl-6">将其他数据类型转换成String类型<ul class="lvl-4"><li class="lvl-10"><p>toString()</p><p>该方法不会影响原来变量，它会将转换的结构返回。注意<strong>Null和Undefined没有toString方法</strong>，如果调用会报错</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<br>a = a.<span class="hljs-title function_">toString</span>();<br></code></pre></td></tr></table></figure><ul class="lvl-6"><li class="lvl-14"><p>String()<br>将被转换的数据作为参数传递给函数。使用String函数做类型强制转换时，对于Number和Boolean就是调用toString()方法，对于null和undefined，就不会调用toString()方法，它会将null直接转换成”null”，将undefined转换成”undefined”。</p></li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<br>a = <span class="hljs-title class_">String</span>(a);<br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-7">将其他的数据类型转换为Number类型<ul class="lvl-4"><li class="lvl-10">Number()<ol><li class="lvl-15">如果是纯数字的字符串，则直接将其转换为数字。</li><li class="lvl-15">如果字符串中有非自数字的内容，则转换为NaN。</li><li class="lvl-15">布尔类型转换成数字，true转成1，false转成0。</li><li class="lvl-15">Null转成数字0。</li><li class="lvl-15">Undefined转成数字NaN。</li></ol></li><li class="lvl-10">parseInt(),parseFloat()<ol><li class="lvl-15">parseInt()把一个字符串转换为一个整数，只取整数部分</li><li class="lvl-15">parseFloat()把一个字符串转换为一个浮点数，可获得有效消暑；</li><li class="lvl-15">对非String使用parseInt()或parseFloat()，它会将其转换为String。</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;123abc&#x27;</span>,<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&#x27;12.34.56ab&#x27;</span>;<br>a = <span class="hljs-built_in">parseInt</span>(a);<span class="hljs-comment">//a:123</span><br>b = <span class="hljs-built_in">parseFloat</span>(b);<span class="hljs-comment">//b:12.34</span><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-7">将其他的数据类型转换为Boolean类型<ul class="lvl-4"><li class="lvl-10">Boolean()<br>1. 对于数字，0和NaN是false，其余的都是true。<br>2. 对于字符串，空串是false，其余的都是true。<br>3. 对于null和undefined，都是false。<br>4. 对于对象，都是true。</li></ul></li></ol></li><li class="lvl-3"><p>隐式类型转换</p><ol><li class="lvl-6">转换为String类型<ul class="lvl-4"><li class="lvl-10">为任意的数据加一个空串</li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;<br>a = a + <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-comment">//a: &quot;123&quot;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-7">转换为Number类型<ul class="lvl-4"><li class="lvl-10">在数据前面加一个+</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;123&#x27;</span><br>a = +a <span class="hljs-comment">//a:123</span><br></code></pre></td></tr></table></figure></li><li class="lvl-7">转换为Boolean类型<ul class="lvl-4"><li class="lvl-9">为任意的数据取两次反</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>a = !!a <span class="hljs-comment">//a:true</span><br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础知识</title>
    <link href="/2024/03/02/CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/03/02/CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1>CSS基础</h1><p>CSS可以控制如内容的字体、颜色、大小和间距这些。一条CSS的样式定义包括属性和属性值，他们共同决定网页的外观</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* p 选择符用来选择页面中的所有 &lt;p&gt; 标签 */</span><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-comment">/* color 属性用来定义文本颜色，这里为黄色 */</span><br>    <span class="hljs-attribute">color</span>: yellow; <br>    <span class="hljs-comment">/* background-color 属性用来定义元素的背景色，这里为黑色 */</span><br>    <span class="hljs-attribute">background-color</span>: black；<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CSS基础语法">CSS基础语法</h2><h3 id="基本语法">基本语法</h3><p>由选择器指定CSS作用的对象，在一对大括号{ }内写一条或多条生命，声明由属性和属性值构成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">selector &#123;<br>    declaration1：value1;<br>    declaration2：value2;<br>    ...<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="CSS选择器的概念">CSS选择器的概念</h2><p>CSS选择器，是元素和其他部分组合起来告诉浏览器哪个HTML元素应当是被选为应用规则中的CSS属性值的方式。</p><ol><li class="lvl-3"><p>通配选择器，由一个星号<code>*</code>代指它选中了文章的所有内容</p></li><li class="lvl-3"><p>类型选择器，也叫标签名选择器或者是元素选择器，它在文档中选择了一个HTML标签/元素</p></li><li class="lvl-3"><p>类选择器，以一个句点<code>.</code>开头，会选择文档中应用了这个类的所有元素。</p></li><li class="lvl-3"><p>id选择器，开头为<code>#</code>而非句点，不过基本上和类选择器是同种用法。一个ID一般用到一次，虽然用多次也能正常显示，但是通过Javascript通过id控制元素就会发生错误。</p></li></ol><img src="/2024/03/02/CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.png" class="" title="这是图片的说明"><p>层叠是CSS的一个基本特征，意为多个选择符之间具有特定的优先级，它是一个定义了如何合并来自多个源的属性值的算法。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>段落最后颜色是蓝色，因为后面的样式会覆盖前面的样式</p><p>这是在同样优先级的情况下，如果在优先级不同的情况下呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.special</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;    <br>&#125;<br><br><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p>类选择器比元素选择器的优先级高，这次段落颜色将会变红，即使它是前面的样式。</p><p>所以，在同优先级的情况下，后定义的生效，不同级则优先级高的生效。各优先级关系，一般来说，选择器的优先级，范围越小，优先级越高。</p><p>id选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配符选择器</p><img src="/2024/03/02/CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.png" class="" title="这是图片的说明"><h2 id="CSS基本样式">CSS基本样式</h2><p>常用样式：</p><ol><li class="lvl-3"><p><code>font-size: 字体大小 px</code></p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-weight</span>: normal; //字体粗细<br><span class="hljs-attribute">font-style</span>: italic; //字体倾斜<br></code></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p><code>text-align: center</code>文本对齐</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">text-decoration</span>: none; //无装饰<br><span class="hljs-attribute">text-decoration</span>: overline; //上划线<br><span class="hljs-attribute">text-decoration</span>: line-through; //中划线<br><span class="hljs-attribute">text-decoration</span>: underline; //下划线<br><span class="hljs-attribute">text-transform</span>: uppercase; //文本转换，全部换为大写字母<br><span class="hljs-attribute">text-indent</span>: <span class="hljs-number">50px</span>; //首行缩进<br><span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">3px</span>; //字母间距<br><span class="hljs-attribute">word-spacing</span>: <span class="hljs-number">10px</span>; //单词间距<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">0.8</span>; //行间距<br><span class="hljs-attribute">white-space</span>: nowrap; //禁用<span class="hljs-selector-tag">html</span>框中文字编辑时的换行符（不必懂）<br><span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> red; //分别是文本的水平、垂直阴影以及阴影的模糊效果、阴影颜色<br></code></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p><code>color: 字体颜色</code></p></li><li class="lvl-3"><p><code>background: 背景样式</code></p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-color</span>: blue;   //颜色名称方式<br><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); //RGB方式<br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;     //十六进制方式<br><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;bg.png&quot;</span>)  ; //设置背景图片<br><span class="hljs-attribute">background-size</span>: contain/cover; // 图片相对于盒子的尺寸<br><span class="hljs-attribute">background-repeat</span>: repeat-x;   //沿x方向阵列<br><span class="hljs-attribute">background-position</span>: right top; //设置背景图片初始位置<br><span class="hljs-attribute">background-attachment</span>: fixed;  //背景图片是否随网页滑动<br><span class="hljs-attribute">background</span>: <span class="hljs-number">#ffffff</span> <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;tree.png&quot;</span>) no-repeat right top;//简写形式<br></code></pre></td></tr></table></figure><ol start="5"><li class="lvl-3"><p><code>height</code>,<code>weight</code>,<code>margin</code>,<code>padding</code>,<code>border</code></p></li></ol><img src="/2024/03/02/CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.png" class="" title="这是图片的说明"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">border-style</span>: solid; // 边框样式<br>  <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#ccc</span>; // 边框颜色<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">15px</span>; // 边框宽度<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>; // 允许你设置元素的外边框圆角,该属性是将这四个属性 <span class="hljs-attribute">border-top-left-radius</span>、<span class="hljs-attribute">border-top-right-radius</span>、<span class="hljs-attribute">border-bottom-right-radius</span>，和 <span class="hljs-attribute">border-bottom-left-radius</span> 简写为一个属性。<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">15px</span> solid green; //边框粗细  实线  颜色 ，dotted是点线，double是双线，dashed是虚线<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;<br>&#125;<br>//<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;  设置内容的高度<br>//<span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;  设置内容的宽度<br></code></pre></td></tr></table></figure><ol start="6"><li class="lvl-3"><p><code>outline-style: 轮廓样式</code></p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">outline-color</span>: red;  //轮廓颜色<br><span class="hljs-attribute">outline-style</span>: dotted;  //轮廓样式<br><span class="hljs-attribute">outline-width</span>: thin;  轮廓宽度<br><span class="hljs-attribute">outline</span>: <span class="hljs-number">5px</span> solid yellow;   简写轮廓属性<br><span class="hljs-attribute">outline-offset</span>: <span class="hljs-number">25px</span>;//轮廓偏移<br></code></pre></td></tr></table></figure><p>轮廓（outline）和边框（border）的区别：</p><ol><li class="lvl-4"><p>border可应用于几乎所有有形的html元素，而outline是针对链接、表单控件等元素设计</p></li><li class="lvl-4"><p>outline的效果将随元素的focus而自动出现（除非手动设置outline-style），相应的由blur而自动消失。这些都是浏览器的默认行为，无需Javascript配合CSS来控制</p></li><li class="lvl-4"><p>outline是不占空间的，不会像border那样影响元素的尺寸或位置，也不会增加额外的width或者height</p></li><li class="lvl-4"><p>对于input之类的表单控件，当你手动设置outline-style，它将不会采用默认的触发方式，而是直接显示，在没有手动设置outline-style的情况下，outline-width不生效。</p></li><li class="lvl-3"><p><code>cursor: pointer;</code> 鼠标呈现为指示链接的一只手</p></li></ol><h2 id="CSS伪元素和伪类">CSS伪元素和伪类</h2><p><strong>什么是伪类？</strong></p><p>伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。</p><p><strong>语法</strong></p><p>伪类就是开头为冒号的关键字：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">selector: pseudo-class-name&#123;&#125;<br></code></pre></td></tr></table></figure><p>常见伪类：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-comment">/* 在用户将指针挪到元素上的时候才会激活 */</span><br><span class="hljs-selector-pseudo">:focus</span> <span class="hljs-comment">/* 获得焦点的元素激活 */</span><br></code></pre></td></tr></table></figure><p><strong>什么是伪元素？</strong></p><p>伪元素是一个附加到选择器末的关键词，允许你对被选择元素的特定部分修改样式。</p><p><strong>语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">selector::pseudo-element &#123;<br>  property: value;<br>&#125;<br></code></pre></td></tr></table></figure><p>常见伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">::after</span> <span class="hljs-comment">/* 用来创建一个伪元素，作为已选中元素的最后一个子元素,通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素 */</span><br><span class="hljs-selector-pseudo">::before</span> <span class="hljs-comment">/* 用来创建一个伪元素，作为已选中元素的第一个子元素，其余同上 */</span><br><span class="hljs-attribute">content</span> <span class="hljs-comment">/* 用于在元素的 ::before 和 ::after 伪元素中插入内容 */</span><br></code></pre></td></tr></table></figure><h2 id="HTMl和CSS的结合方式">HTMl和CSS的结合方式</h2><ol><li class="lvl-3"><p>行内式：html中的属性标签style：适用于单纯只有一个标签需要设置时的特殊样式。如果多个标签需要应用同一个样式，建议采用内嵌式。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue;background-color: yellow;border: 1px solid black;&quot;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>内嵌式：建议在head中使用，使用标签 style 适用于当前页面多个标签使用同一个样式。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">p</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: blue;</span><br><span class="language-css">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>内嵌<span class="hljs-tag">&lt;<span class="hljs-name">p</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>/&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>外链式：link:适用于多个页面使用同一个样式时。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/my.css&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>注意：link中href属性必须有，表示链接的css文件。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的HTML知识</title>
    <link href="/2024/03/01/%E5%B8%B8%E7%94%A8%E7%9A%84HTML%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/03/01/%E5%B8%B8%E7%94%A8%E7%9A%84HTML%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1>HTML是什么？</h1><p>超文本标记语言(英语:HyperText Markup Language,简称:HTML)是一种用于创建网页的标准标记语言。HTML是一种基础技术,常与CSS、JavaScript一起被众多网站用于设计网页、网页应用程序以及移动动应用程序的用户界面。网页浏览器可以读取HTML文件,并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的的呈现,使之成为一种标记语言而非编程语言。</p><h1>常用的HTML语法概述</h1><ol><li class="lvl-3"><p>HTML标签是由<strong>尖括号</strong>包围的关键词，例如 &lt;html&gt;</p></li><li class="lvl-3"><p>HTML标签通常是成对出现的，例如 &lt;html&gt;和/</html>，称为双标签。</p></li><li class="lvl-3"><p>有些特殊的标签必须是单个标签，例如&lt;br /&gt;，称为单标签。</p></li><li class="lvl-3"><p>双标签关系可以分为两类：包含关系（父子关系）和并列关系（兄弟关系）</p></li></ol><h2 id="HTML骨架代码">HTML骨架代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 不算是一个html标签，是文档规范，让浏览器能够正确地渲染页面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 根元素，lang表示文档语言类型为英文 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- 向浏览器传递网页的基本信息和配置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 告诉浏览器使用utf-8编码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 确保在移动设备上正确显示和缩放网页内容 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 页面选项卡中的标题 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 页面呈现区域 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li class="lvl-3"><p>head:包含一些与文档相关的元数据和其他重要的信息，内容不会在浏览器中显示。</p><ol><li class="lvl-6"><code>title</code>：定义文档的标题，不同的页面类型有不同的格式。比如：主页，一般是网页名称+主要关键词。详情页，一般是详情名称+网站名字+简介等等。</li><li class="lvl-6"><code>link</code>：指定当前文档和外部资源的关系</li><li class="lvl-6"><code>meta</code>：设置网页的元数据，例如字符集、描述、关键词等</li><li class="lvl-6"><code>script</code>引入Javascript代码或链接外部Javascript文件</li></ol></li><li class="lvl-3"><p>body：定义网页的主题内容，是HTML文档的一个必要组成部分，包含了所有对用户可见的内容，如文本、图像、链接、段落、标题、表格、表单等。</p></li></ol><h1>常用HTML元素</h1><h3 id="1-标题标签，作为标题使用，根据重要性递减">1. 标题标签，作为标题使用，根据重要性递减</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>......<br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-段落标签，用于定义段落，可以将整个网页分为若干个段落">2. 段落标签，用于定义段落，可以将整个网页分为若干个段落</h3><pre><code class="hljs">`&lt;p&gt;&lt;/p&gt;`</code></pre><h3 id="3-换行标签和水平分割线标签，单标签">3. 换行标签和水平分割线标签，单标签</h3><ul class="lvl-0"><li class="lvl-2"><p>换行<code>&lt;br /&gt;</code>文本强制换行显示</p></li><li class="lvl-2"><p>水平分割线：<code>&lt;hr/&gt;</code>插入水平分割线</p></li></ul><h3 id="4-文本格式化标签">4. 文本格式化标签</h3><table><thead><tr><th style="text-align:left">标签名</th><th style="text-align:left">效果</th><th style="text-align:left">标签名</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;strong&gt;&lt;/strong&gt;</code></td><td style="text-align:left">加粗</td><td style="text-align:left"><code>&lt;b&gt;&lt;/b&gt;</code></td><td style="text-align:left">加粗</td></tr><tr><td style="text-align:left"><code>&lt;em&gt;&lt;/em&gt;</code></td><td style="text-align:left">倾斜</td><td style="text-align:left"><code>&lt;i&gt;&lt;/i&gt;</code></td><td style="text-align:left">倾斜</td></tr><tr><td style="text-align:left"><code>&lt;ins&gt;&lt;/ins&gt;</code></td><td style="text-align:left">下划线</td><td style="text-align:left"><code>&lt;u&gt;&lt;/u&gt;</code></td><td style="text-align:left">下划线</td></tr><tr><td style="text-align:left"><code>&lt;del&gt;&lt;/del&gt;</code></td><td style="text-align:left">删除线</td><td style="text-align:left"><code>&lt;s&gt;&lt;/s&gt;</code></td><td style="text-align:left">删除线</td></tr></tbody></table><h3 id="5-盒子标签">5. 盒子标签</h3><p><code>&lt;div&gt;&lt;/div&gt;</code>一行只能放一个<code>&lt;span&gt;&lt;/span&gt;</code>一行能放多个</p><h3 id="6-图像标签，单标签">6. 图像标签，单标签</h3><p><code>&lt;img /&gt;</code></p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">作用</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">alt</td><td style="text-align:left">替换文本</td><td style="text-align:left">图片无法显示时候显示的文字</td></tr><tr><td style="text-align:left">title</td><td style="text-align:left">提示文本</td><td style="text-align:left">鼠标悬停在图片上面时候显示的文字</td></tr><tr><td style="text-align:left">width</td><td style="text-align:left">图片的宽度</td><td style="text-align:left">值为数字</td></tr><tr><td style="text-align:left">height</td><td style="text-align:left">图片的高度</td><td style="text-align:left">值为数字</td></tr></tbody></table><h3 id="7-超链接标签">7. 超链接标签</h3><p><code>&lt;a href=&quot;&quot; target = &quot;&quot;&gt;链接文本&lt;/a&gt;</code></p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">href</td><td style="text-align:center">用于指定链接目标的ur地址，(必须属性)当为标签应用href属性时，它就具有了超链接的功能；</td></tr><tr><td style="text-align:center">target</td><td style="text-align:center">用于指定链接页面的打开方式，其中_self为默认值(在本窗口中打开)，_ blank为在新窗口中打开方式</td></tr></tbody></table><h3 id="8-表格标签">8. 表格标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span> <span class="hljs-comment">&lt;!-- 用于定义表格的标题部分 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 表示表格的一行 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>列标题1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span> <span class="hljs-comment">&lt;!-- 表示表格的表头单元格 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>列标题2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>列标题3<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span> <span class="hljs-comment">&lt;!-- 用于定义表格的主体部分 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行1，列1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-comment">&lt;!-- 表示表格的数据单元格 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行1，列2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行1，列3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行2，列1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行2，列2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>行2，列3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><table border="1">  <thead> <!-- 用于定义表格的标题部分 -->    <tr>  <!-- 表示表格的一行 -->      <th>列标题1</th> <!-- 表示表格的表头单元格 -->      <th>列标题2</th>      <th>列标题3</th>    </tr>  </thead>  <tbody> <!-- 用于定义表格的主体部分 -->    <tr>      <td>行1，列1</td> <!-- 表示表格的数据单元格 -->      <td>行1，列2</td>      <td>行1，列3</td>    </tr>    <tr>      <td>行2，列1</td>      <td>行2，列2</td>      <td>行2，列3</td>    </tr>  </tbody></table><p>常用属性：常用属性：</p><ul class="lvl-0"><li class="lvl-4"><p>border：表示表格的边框宽度，单位是像素，即px；</p></li><li class="lvl-4"><p>rowspan：表示多行合并，可以指定具体要合并的行数；(不要忘记删除多余的单元格)</p></li><li class="lvl-4"><p>colspan：表示多列合并，可以指定具体要合并的列数；(不要忘记删除多余的单元格)</p></li><li class="lvl-4"><p>cellpadding：表示单元格边缘与其单元格内容之间的空白间距；</p></li><li class="lvl-4"><p>cellspacing：表示单元格之间的空白间距；</p></li><li class="lvl-4"><p>width：表示表格的宽度；</p></li><li class="lvl-4"><p>align：表示表格相对周围元素的对齐方式。</p></li></ul><h3 id="9-列表标签">9. 列表标签</h3><p>分为：有序列表、无序列表、自定义列表</p><ul class="lvl-0"><li class="lvl-2"><p>无序列表：使用<code>&lt;ul&gt;</code>标签，里面放着<code>&lt;li&gt;</code>标签，此列项目使用粗体圆点进行标记</p><p><strong><code>&lt;ul&gt;&lt;/ul&gt;</code>里只能嵌套<code>&lt;li&gt;</code>标签</strong></p><p><strong><code>&lt;li&gt;&lt;/li&gt;</code>中可以放任何标签</strong></p><p>type属性可以指定列表项的符号类型，如<code>disc</code>：小圆点，<code>circle</code>：空心圆圈，<code>square</code>：方块</p></li><li class="lvl-2"><p>有序列表：使用<code>&lt;ol&gt;</code>标签，里面放着<code>&lt;li&gt;</code>标签，项目列表使用数字进行标记</p><p><strong><code>&lt;ol&gt;&lt;/ol&gt;</code>中只能嵌套<code>&lt;li&gt;</code>标签</strong></p><p>type属性可以指定列表项的符号类型，如<code>i</code>：罗马数字开始</p><p><code>start</code>属性：指定起始编号</p></li><li class="lvl-2"><p>自定义列表：使用<code>&lt;dl&gt;</code>标签，<code>&lt;dt&gt;</code>标签用来定义项目/名字，<code>&lt;dd&gt;</code>描述每一个项目/名字</p></li></ul><p><strong><code>&lt;dl&gt;&lt;/dl&gt;</code>里面只能包含<code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>无序列表:<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Tea<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>有序列表:<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Tea<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>自定义列表:<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>- black hot drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>- white cold drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="10-表单标签">10.表单标签</h3><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;form&gt; &lt;/form&gt;</code>:表单域标签，表单域就是一个包含表单元素的区域</p></li><li class="lvl-2"><p><code>&lt;input/&gt;</code>:输入表单元素</p></li><li class="lvl-2"><p><code>&lt;lable&gt;&lt;lable&gt;</code>:绑定一个表单元素，当点击lable标签内的文本时，会自动将焦点转到对应的表单元素上，lable的for属性必须得与相关元素的id属性相同</p></li><li class="lvl-2"><p><code>&lt;select&gt;&lt;/select&gt;</code>:下拉表单元素，用于定义一个下拉列表</p></li><li class="lvl-2"><p><code>&lt;option&gt;&lt;/option&gt;</code>:下拉列表中元素，定义selected = “selected”属性时，当前项为默认选中项</p></li><li class="lvl-2"><p><code>&lt;textarea&gt;&lt;/textarea&gt;</code>文本域元素，用于定义一个多行文本输入框，cols属性规定每行的字符数，rows属性规定显示的行数</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 文本输入框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 密码输入框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密码:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 单选按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>性别:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 复选框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;subscribe&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;subscribe&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;subscribe&quot;</span>&gt;</span>订阅推送信息<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 下拉列表 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span>国家:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span>CN<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;usa&quot;</span>&gt;</span>USA<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;uk&quot;</span>&gt;</span>UK<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 提交按钮 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>标签的常用属性：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">属性值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">type</td><td style="text-align:center">见下表</td><td style="text-align:center">用于设置标签的不同形式</td></tr><tr><td style="text-align:center">value</td><td style="text-align:center">用户自定义</td><td style="text-align:center">设置input元素的默认值</td></tr></tbody></table><p>标签type属性值</p><table><thead><tr><th style="text-align:center">属性值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">button</td><td style="text-align:center">定义可点击按钮</td></tr><tr><td style="text-align:center">checkbox</td><td style="text-align:center">定义复选框，一组复选框name属性必须相同</td></tr><tr><td style="text-align:center">password</td><td style="text-align:center">定义密码字段，该字段中的字符被掩码</td></tr><tr><td style="text-align:center">radio</td><td style="text-align:center">定义单选按钮，一组单选按钮的name属性必须相同</td></tr><tr><td style="text-align:center">reset</td><td style="text-align:center">定义重制按钮，清除表单中的所有数据</td></tr><tr><td style="text-align:center">submit</td><td style="text-align:center">定义提交按钮，提交到action属性指定的地址</td></tr><tr><td style="text-align:center">text</td><td style="text-align:center">定义单行的输入字段，用户可在其中输入文本，默认宽度为20字符</td></tr></tbody></table><h3 id="11-注释和特殊字符">11.注释和特殊字符</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 我是注释 --&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">特殊字符</th><th style="text-align:center">描述</th><th style="text-align:center">字符代码</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">空格符</td><td style="text-align:center">&amp;nbsp;</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于号</td><td style="text-align:center">&amp;lt;</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于号</td><td style="text-align:center">&amp;gt;</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">和</td><td style="text-align:center">&amp;amp;</td></tr><tr><td style="text-align:center">±</td><td style="text-align:center">正负号</td><td style="text-align:center">\plusmn;</td></tr><tr><td style="text-align:center">×</td><td style="text-align:center">乘号</td><td style="text-align:center">&amp;times;</td></tr><tr><td style="text-align:center">÷</td><td style="text-align:center">除号</td><td style="text-align:center">&amp;divide;</td></tr></tbody></table><h3 id="12-常用的HTML纯语义话标签">12.常用的HTML纯语义话标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--标题头部区域内容(用于页面或页面中的一块区域)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--标题脚部区域内容(用于页面或页面中的一块区域) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--表示一个包含在HTML文档中的独立部分，它没有更具体的语义元素来表示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--顾名思义，用来定义文章的部分。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--用来表示跟当前页面的内容没有很相关的部分，通常用于显示侧边栏或者补充的内容。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--一般表示此部分是导航栏--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br></code></pre></td></tr></table></figure><h1>分类（针对元素显示模式）</h1><table><thead><tr><th style="text-align:center">元素模式</th><th style="text-align:center">元素排列</th><th style="text-align:center">设置样式</th><th style="text-align:center">默认宽度</th><th style="text-align:center">包含</th></tr></thead><tbody><tr><td style="text-align:center">块级元素</td><td style="text-align:center">一行只能放一个</td><td style="text-align:center">可以设置宽度高度</td><td style="text-align:center">容器的100%</td><td style="text-align:center">标题标签，段落标签，换行标签，水平分割线，div</td></tr><tr><td style="text-align:center">行内元素</td><td style="text-align:center">一行可以放多个</td><td style="text-align:center">不可以直接设置宽度高度</td><td style="text-align:center">它本身内容的宽度</td><td style="text-align:center">span 图像标签 文本格式化标签 输入标签</td></tr><tr><td style="text-align:center">行内块元素</td><td style="text-align:center">一行可以放多个</td><td style="text-align:center">可以设置宽度高度</td><td style="text-align:center">它本身内容的宽度</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 定位</title>
    <link href="/2024/02/29/CSS-%E5%AE%9A%E4%BD%8D/"/>
    <url>/2024/02/29/CSS-%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1>定位 position</h1><p><strong>什么是定位？</strong></p><p>定位的整个想法是允许我们覆盖上面描述的基本文档流行为，以产生有趣的效果。如果你想稍微改变布局中一些盒子的位置，使它们的默认布局流程位置稍微有点古怪，不舒服的感觉呢？定位是你的工具。或者，如果你想要创建一个浮动在页面其他部分顶部的 UI 元素，并且/或者始终停留在浏览器窗口内的相同位置，无论页面滚动多少？定位使这种布局工作成为可能。</p><p>CSS提供了许多不同类型的定位，你可以对HTML元素生效。要使某个元素上的特定类型的定位，我们使用<code>position</code>属性。</p><img src="/2024/02/29/CSS-%E5%AE%9A%E4%BD%8D/1.png" class="" title="这是图片的说明"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.son1</span>&#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;<br>&#125;//设置class为son1的盒子为绝对定位，距离父元素上边线<span class="hljs-number">10px</span><br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">语义</th></tr></thead><tbody><tr><td style="text-align:center">static</td><td style="text-align:center">静态定位</td></tr><tr><td style="text-align:center">relative</td><td style="text-align:center">相对定位</td></tr><tr><td style="text-align:center">absolute</td><td style="text-align:center">绝对定位</td></tr><tr><td style="text-align:center">fixed</td><td style="text-align:center">固定定位</td></tr><tr><td style="text-align:center">sticky</td><td style="text-align:center">粘性定位</td></tr></tbody></table><h2 id="静态定位">静态定位</h2><p>静态定位是每个元素获取的默认值——它只是意味着“将元素放入它在文档布局流中的正常位置”——这里没有什么特别的</p><h2 id="相对定位">相对定位</h2><p>相对定位是我们将要看的第一个位置类型。它与静态定位非常相似，但是他有这几个特点</p><ul class="lvl-0"><li class="lvl-2"><p>不脱离标准流，保留原来位置</p></li><li class="lvl-2"><p>参考点：<strong>原来的自身位置</strong></p></li></ul><p>参考点是原来的自身位置，那么如何改变元素位置？</p><h2 id="介绍top、bottom、left-和-right">介绍top、bottom、left 和 right</h2><p><code>top</code>,<code>bottom</code>,<code>left</code>,<code>right</code>来精确制定要将定位元素移动到的位置。</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">语义</th></tr></thead><tbody><tr><td style="text-align:center">top</td><td style="text-align:center">定位元素距离其父元素的上边线的距离</td></tr><tr><td style="text-align:center">bottom</td><td style="text-align:center">定位元素距离其父元素的下边线的距离</td></tr><tr><td style="text-align:center">right</td><td style="text-align:center">定位元素距离其父元素的右边线的距离</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">定位元素距离其父元素的左边线的距离</td></tr></tbody></table><h2 id="绝对定位">绝对定位</h2><p>绝对定位带来了非常不同的结果，他有如下几个特点</p><ul class="lvl-0"><li class="lvl-2"><p>脱离标准流，不占用原来位置</p></li><li class="lvl-2"><p>参考点：离自己最近的设置了定位的父元素移动</p></li><li class="lvl-2"><p>如果没有祖先元素，或者祖先元素没有定位，则以浏览器为参照物</p></li><li class="lvl-2"><p>行内元素设置了固定定位和绝对定位，会转为块。</p></li></ul><h2 id="固定定位">固定定位</h2><p>还有一种类型的定位覆盖——fixed。这与绝对定位的工作方式完全相同，只有一个主要区别，<strong>固定定位参考点永远是浏览器窗口</strong>，这意味着你可以利用固定定位创建导航菜单之类的元素。</p><h2 id="粘性定位">粘性定位</h2><p>还有一个可用的位置称为sticky，它基本上是相对定位和固定定位的混合体，有着如下几个特点</p><ul class="lvl-0"><li class="lvl-2"><p>以浏览器的窗口为参照点移动元素（固定定位）</p></li><li class="lvl-2"><p>占有原来的位置，不脱离标准流（相对定位）</p></li><li class="lvl-2"><p>必须添加<code>top</code>,<code>bottom</code>,<code>left</code>,<code>right</code>其中一个才有效，跟页面滚动搭配使用，例如，它可用于使导航栏随页面滚动直到特定点，然后粘贴在页面顶部。</p></li></ul><h2 id="“子绝父相”的思想">“子绝父相”的思想</h2><p>子级使用绝对定位，父级则需要相对定位</p><ul class="lvl-0"><li class="lvl-2"><p>父盒子需要加定位限制子盒子在父盒子内显示</p></li><li class="lvl-2"><p>父盒子布局时，需要占有位置</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 浮动布局</title>
    <link href="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
    <url>/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>在说浮动之前，我们先来了解一下<strong>标准流</strong>。</p><ul class="lvl-0"><li class="lvl-2">标准流又称为普通流，是浏览器<strong>默认</strong>的排版方式。</li><li class="lvl-2">标准流中元素会自动按照从左往右从上往下进行排列。</li></ul><h1>浮动 float</h1><p><strong>什么是浮动？</strong></p><p>使元素脱离了标准流，向左或向又移动，直到碰到父元素或另一个浮动元素的边缘为止。</p><p>最初，引入<code>float</code>属性是为了能让Web开发人员实现简单的布局，包括在一列文本中浮动的图像，文字环绕在它的左边或右边。你可能在报纸版面看到过。</p><p><strong>让盒子浮动起来</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.son1</span>&#123;<br>    <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br>&#125; //设置class为son1的盒子向左浮动<br></code></pre></td></tr></table></figure><p>参数</p><table><thead><tr><th style="text-align:center">属性值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">none</td><td style="text-align:center">元素不浮动</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">元素向左浮动</td></tr><tr><td style="text-align:center">right</td><td style="text-align:center">元素向右浮动</td></tr></tbody></table><h2 id="特性">特性</h2><ol><li class="lvl-3"><p>加了浮动的元素盒子是“浮起来”的，脱离了标准流，漂浮在其他标准盒子上，原来的位置空了下来，漏给了标准流盒子</p></li><li class="lvl-3"><p>浮动元素具有<strong>行内块元素</strong>特性</p><ol><li class="lvl-6">任何元素都可以浮动，不管之前是什么模式的元素，添加浮动之后都具有行内块元素相似的特性。</li><li class="lvl-6">元素设置浮动后，原来设置的宽高起作用，默认在当前包含块左上一排，如果前面有块级元素，会排在元素的下面。</li></ol></li></ol><img src="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/1.png" class="" title="这是图片的说明"><ol start="3"><li class="lvl-6"><p>如果原来没有设置宽高，浮动后根据内容决定大小</p></li></ol><img src="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/2.png" class="" title="这是图片的说明"><img src="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/3.png" class="" title="这是图片的说明"><ol start="3"><li class="lvl-3"><p>浮动的元素是相互贴靠在一起的(<strong>没有缝隙</strong>)，如果父级宽度装不下这些浮动的盒子，多出的盒子会<strong>另起一行</strong>对齐。</p></li><li class="lvl-3"><p>浮动元素<strong>不会遮挡</strong>标准流中的文字。</p></li></ol><h2 id="清除浮动">清除浮动</h2><p>我们发现，一个浮动元素会被移出正常文档流，且其他元素会显示在它的下方。如果我们不想让剩余元素也收到浮动元素的影响，我们需要<strong>清除浮动</strong></p><ul class="lvl-0"><li class="lvl-2"><p>清除浮动的本质是<strong>清除浮动造成的影响</strong></p></li><li class="lvl-2"><p>如果父盒子本身有高度，则不需要清除浮动</p></li><li class="lvl-2"><p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了。</p></li><li class="lvl-2"><p>清除浮动主要是为了解决父级元素因为子级浮动引起的内部高度为0的问题</p></li></ul><h3 id="清除浮动的方法">清除浮动的方法</h3><ol><li class="lvl-3"><p>额外标签法</p></li><li class="lvl-3"><p>父级添加<code>overflow</code>属性</p></li><li class="lvl-3"><p>父级添加<code>after</code>伪元素</p></li><li class="lvl-3"><p>父级添加双伪元素</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS Flex布局</title>
    <link href="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/"/>
    <url>/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1>flex布局的基本概念</h1><ul class="lvl-0"><li class="lvl-2">flex布局是一种一维的布局模型，它给子元素之间提供了强大的空间分布和对齐能力。</li><li class="lvl-2">我们之所以说flex是一种一维的布局，是因为一个flex容器一次只能处理一个维度上的元素布局，一行或者一列。</li><li class="lvl-2">采用flex布局的元素，称为<strong>flex容器</strong>，它的所有子元素自动成为容器成员，称为<strong>flex项目</strong>，容器存在两根轴，默认项目按照主轴排列。</li></ul><h1>flexbox的两根轴线</h1><p>当使用flex布局时，首先应该想到两根轴线——主轴和交叉轴，主轴由<code>flex-direction</code>定义，另一根轴垂直于它，flexbox的所有属性都跟这两根轴线有关。</p><p>首先，先设置flex容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;<br>    <span class="hljs-attribute">display</span>: flex | inline-flex; //块元素使用<span class="hljs-attribute">flex</span>，行内块元素使用inline-<span class="hljs-attribute">flex</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="容器属性">容器属性</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-direction</code></p></li><li class="lvl-2"><p><code>flex-wrap</code></p></li><li class="lvl-2"><p><code>flex-flow</code></p></li><li class="lvl-2"><p><code>justify-content</code></p></li><li class="lvl-2"><p><code>align-items</code></p></li><li class="lvl-2"><p><code>align-content</code></p></li></ul><h2 id="主轴">主轴</h2><p>主轴由<code>flex-direction</code>定义，可以取四个值</p><ul class="lvl-0"><li class="lvl-2"><p><code>row</code></p></li><li class="lvl-2"><p><code>row-reverse</code></p></li><li class="lvl-2"><p><code>column</code></p></li><li class="lvl-2"><p><code>column-reverse</code></p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>row和row-reverse分别是水平排列和水平逆序排列</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/1.svg" class="" title="这是图片的说明"><ul class="lvl-0"><li class="lvl-2"><p>column 和 column-reverse 分别是垂直排列和垂直逆序排列</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/2.svg" class="" title="这是图片的说明"><h2 id="交叉轴">交叉轴</h2><p>交叉轴垂直于主轴，所以如果你的<code>flex-direction</code>设置成了<code>row</code>或者<code>row-reverse</code>的话，交叉轴的方向就是沿着上下方向延伸的。</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/3.svg" class="" title="这是图片的说明"><p>如果主轴方向设成了<code>column</code>或者<code>column-reverse</code>交叉轴就是水平方向</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/4.svg" class="" title="这是图片的说明"><h1>用 flex-wrap 实现多行 Flex 容器</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-wrap</span>: no-wrap | wrap | wrap-reverse;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>nowrap</code> （默认）不换行</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/5.png" class="" title="这是图片的说明"><ul class="lvl-0"><li class="lvl-2"><p><code>wrap</code> 换行，第一行在上方</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/6.png" class="" title="这是图片的说明"><ul class="lvl-0"><li class="lvl-2"><p><code>wrap-reverse</code> 换行，第一行在下方</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/7.png" class="" title="这是图片的说明"><h1>简写属性 flex-flow</h1><p>你可以将两个属性 <code>flex-direction</code> 和 <code>flex-wrap</code> 组合为简写属性 <code>flex-flow</code>。第一个指定的值为 <code>flex-direction</code> ，第二个指定的值为 <code>flex-wrap</code>.</p><h1>元素间的对齐和空间分配</h1><p>Flexbox 的一个关键特性是能够设置 flex 元素沿主轴方向和交叉轴方向的对齐方式，以及它们之间的空间分配。</p><h2 id="align-items">align-items</h2><p><code>align-items</code>属性可以使元素在交叉轴方向对齐</p><p>这个属性的初始值为<code>stretch</code>，这就是为什么 flex 元素会默认被拉伸到最高元素的高度。实际上，它们被拉伸来填满 flex 容器——最高的元素定义了容器的高度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">align-items</span>:flex-start | flex-end | center | baseline | stretch;<br>//Streth 拉伸（子元素不设置高度时的默认值)<br></code></pre></td></tr></table></figure><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/9.png" class="" title="这是图片的说明"><h2 id="justify-content">justify-content</h2><p><code>justify-content</code>属性用来使元素在主轴方向上对齐，主轴方向是通过 <code>flex-direction</code> 设置的方向。</p><p>你可以把值设置为<code>space-between</code>，把元素排列好之后的剩余空间拿出来，平均分配到元素之间，所以元素之间间隔相等。或者使用<code>space-around</code>，使每个元素的左右空间相等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;<br></code></pre></td></tr></table></figure><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/8.png" class="" title="这是图片的说明"><h1>flex元素上的属性</h1><p>为了更好地控制flex元素，有四个属性可以作用于他们：</p><ul class="lvl-0"><li class="lvl-2"><p><code>order</code></p></li><li class="lvl-2"><p><code>flex-grow</code></p></li><li class="lvl-2"><p><code>flex-shrink</code></p></li><li class="lvl-2"><p><code>flex-basis</code></p></li></ul><p>在考虑这几个属性的作用之前，需要先了解一下<strong>可用空间</strong>这个概念，这几个flex属性其实就是改变了flex容器中的可用空间的行为，同时，可用空间对于flex元素的对齐行为也是很重要的。</p><p>假设在 1 个 500px 的容器中，我们有 3 个 100px 宽的元素，那么这 3 个元素需要占 300px 的宽，剩下 200px 的可用空间。在默认情况下，flexbox 的行为会把这 200px 的空间留在最后一个元素的后面。</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/10.svg" class="" title="这是图片的说明"><p>如果期望这些元素能自动地扩展去填充满剩下的空间，那么我们需要去控制可用空间在这几个元素间如何分配，这就是元素上的那些 flex 属性要做的事。</p><h2 id="order属性">order属性</h2><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/11.png" class="" title="这是图片的说明"><h2 id="Flex-元素属性：flex-grow">Flex 元素属性：flex-grow</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p></li><li class="lvl-2"><p>如果容器压根就没有剩余空间，那么即使设置了<code>flex-grow</code>也不会生效。</p></li><li class="lvl-2"><p><code>flex-grow</code>的默认值是0，子项目不做任何比例拉伸，如果将三个子项目的flex-grow属性都设为1，那么他们将按照1:1:1的比例分配剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p></li></ul><h2 id="Flex-元素属性：flex-shrink">Flex 元素属性：flex-shrink</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p></li><li class="lvl-2"><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p></li><li class="lvl-2"><p>负值对该属性无效，如果容器还有剩余空间，同样设置<code>flex-shrink</code>也是无效的。</p></li><li class="lvl-2"><p>如果不希望压缩，我们可以选择换行，只需要设置<code>flex-wrap</code>为<code>wrap</code>就好。</p></li></ul><h2 id="Flex-元素属性：-flex-basis">Flex 元素属性： flex-basis</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-basis</code> 定义了该元素的空间大小，flex 容器里除了元素所占的空间以外的富余空间就是可用空间。该属性的默认值是 <code>auto</code>。此时，浏览器会检测这个元素是否具有确定的尺寸。在上面的例子中，所有元素都设定了宽度（width）为 100px，所以 <code>flex-basis</code> 的值为 100px。</p></li><li class="lvl-2"><p>如果没有给元素设定尺寸，<code>flex-basis</code> 的值采用元素内容的尺寸。这就解释了：我们给只要给 Flex 元素的父元素声明 <code>display: flex</code>，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</p></li></ul><h2 id="Flex属性的简写">Flex属性的简写</h2><ul class="lvl-0"><li class="lvl-2"><p>flex属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p></li><li class="lvl-2"><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p></li><li class="lvl-2"><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法——冒泡排序</title>
    <link href="/2023/11/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/11/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>冒泡排序(Bubble Sort)是一种简单，直观的排序算法，它通过比较相邻两个数据，按照从小到大或者从大到小的顺序进行交换，就像一个泡泡冒上去一样，故得名冒泡排序</p></blockquote><h1 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h1><p>以从小到大为例，冒泡算法是这样实现的：</p><p>遍历原始数据，从第一个数开始，到<strong>倒数第二个</strong>数结束，比较当前数和下一个数的大小，如果当前数比下一个数大，则交换这两个数，这样可以将最大的数转移到末尾，接下来再次遍历，但到<strong>倒数第三个</strong>数结束，可以将第二大的数转移到倒数第二位，以此类推。</p><p>动图演示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="动图演示"></p><p>优点：空间复杂度低，稳定性高</p><p>缺点：时间复杂度，效率低</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bubblesort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span> i, j, temp;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<span class="hljs-comment">//外部循环 </span><br><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n - i; j++)&#123;<span class="hljs-comment">//内部循环 </span><br><span class="hljs-keyword">if</span>(a[j] &gt; a[j + <span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//比较相邻元素大小 </span><br>temp = a[j];<span class="hljs-comment">//交换值 </span><br>a[j] = a[j + <span class="hljs-number">1</span>];<br>a[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<span class="hljs-comment">//写入数据 </span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>&#125;<br>bubblesort(a,<span class="hljs-number">10</span>);<span class="hljs-comment">//排序 </span><br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<span class="hljs-comment">//输出数据 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>&#125;<br> <br>&#125; <br></code></pre></td></tr></table></figure><p>输入数据</p><p><code>2 4 1 3 7 9 6 5 8 10</code></p><p>输出数据</p><p><code>1 2 3 4 5 6 7 8 9 10</code></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言库函数(快速排序)--qsort()</title>
    <link href="/2023/11/20/C%E8%AF%AD%E8%A8%80%E5%BA%93%E5%87%BD%E6%95%B0-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-qsort/"/>
    <url>/2023/11/20/C%E8%AF%AD%E8%A8%80%E5%BA%93%E5%87%BD%E6%95%B0-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-qsort/</url>
    
    <content type="html"><![CDATA[<blockquote><p>qsort()函数是一种用于对数组快速排序的函数，他是一个通用的排序函数，支持对不同类型的元素进行排序</p></blockquote><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>qsort()是包含在C语言标准库&lt;stdlib.h&gt;中的函数，所以想使用该函数应在程序前引用该头文件</p><p><code>#include &lt;stdlib.h&gt;</code></p><h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><p><code>void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</code></p><ul><li><p>base -&gt; 数组名</p></li><li><p>nitems -&gt;元素个数</p></li><li><p>size -&gt; 数组元素所占字节（int,char等所占字节）</p></li><li><p>(*compar)(const void <em>, const void</em>) -&gt; 排序原则（递增，递减等）</p><h2 id="排序原则？"><a href="#排序原则？" class="headerlink" title="排序原则？"></a>排序原则？</h2><p>通过定义一个函数compar，通过这个函数<strong>返回的参数</strong>来去确定排序规则</p><p><strong>注意</strong>：compar函数中参数需要以<strong>const void *a,const void *b**的形式来定义，表示a，b的类型是“未确定”（void），在return时候进行强制类型转换为int型，</strong>*(int*)a-*(int*)b**表示递增顺序，如果递减只需要更换a和b的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> &#123;<br><span class="hljs-keyword">return</span> *(<span class="hljs-type">int</span>*)a-*(<span class="hljs-type">int</span>*)b;<span class="hljs-comment">//递增</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="不同类型元素排序"><a href="#不同类型元素排序" class="headerlink" title="不同类型元素排序"></a>不同类型元素排序</h1><p>对于不同的类型，只需要改变compar函数就可以</p><h2 id="整形（int）"><a href="#整形（int）" class="headerlink" title="整形（int）"></a>整形（int）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">int</span>*)a-*(<span class="hljs-type">int</span>*)b;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点型（double）"><a href="#浮点型（double）" class="headerlink" title="浮点型（double）"></a>浮点型（double）</h2><p><strong>注意！浮点数存在精度损失<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="浮点数并不精确，5.000实际上可能是5.000000000003">[1]</span></a></sup>的问题，运算可能会出错，所以我们选择比较的方式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">double</span>*)a&gt;*(<span class="hljs-type">double</span>*)b?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>;<span class="hljs-comment">//三目运算符，如果前大于后，输出1，反之输出-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符型（char）"><a href="#字符型（char）" class="headerlink" title="字符型（char）"></a>字符型（char）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">char</span>*)a-*(<span class="hljs-type">char</span>*)b;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>升序排序一个10位数数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">int</span>*)a-*(<span class="hljs-type">int</span>*)b;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>&#125;;<br>    qsort(a,<span class="hljs-number">10</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>),compar);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><p><code>1 2 3 4 5 6 7 8 9 10</code></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>浮点数并不精确，5.000实际上可能是5.000000000003<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中常用的字符串函数</title>
    <link href="/2023/11/20/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/"/>
    <url>/2023/11/20/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>想要在c语言中处理字符串，你需要引用&lt;string.h&gt;头文件</li></ul><h2 id="处理字符串的函数"><a href="#处理字符串的函数" class="headerlink" title="处理字符串的函数"></a>处理字符串的函数</h2><h3 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h3><p>函数声明<br><code>size_t strlen (const char *str);</code></p><p>作用：</p><p>返回字符串的长度（’\0’之前的长度，不包括’\0’）</p><p><strong>注意</strong>：</p><p>参数指向的字符串必须要以‘\0’结束</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;hello&quot;</span>;<br>    n = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为5。</p><h3 id="strcpy函数"><a href="#strcpy函数" class="headerlink" title="strcpy函数"></a>strcpy函数</h3><p>函数声明</p><p><code>char * strcpy(char * destination,const * source);</code></p><p>作用：</p><p>把source字符串的内容复制到destination中</p><p><strong>注意</strong>：</p><p>目标空间必须足够大能够存放源字符串</p><p>目标空间不可为”const”</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;world&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str1);<span class="hljs-comment">//操作前的str1</span><br>    <span class="hljs-built_in">strcpy</span>(str1,str2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str1);<span class="hljs-comment">//操作后的str1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">hello<span class="hljs-comment">//操作前的str1</span><br>world<span class="hljs-comment">//操作后的str1，strcpy将后面（str2）的值给了str1</span><br></code></pre></td></tr></table></figure><h3 id="strcat函数"><a href="#strcat函数" class="headerlink" title="strcat函数"></a>strcat函数</h3><p>函数声明</p><p><code>char * strcat(char * destination, const char * source)</code>;</p><p>作用：</p><p>将source的内容拼接到destination上</p><p><strong>注意</strong>：</p><p>destination空间必须足够大</p><p>destination不能为”const”</p><p>不可以自己给自己拼接</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">20</span>]=<span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;world&quot;</span>;<br>    <span class="hljs-built_in">strcat</span>(str1,str2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str1);<br>    <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><p><code>helloworld</code></p><h3 id="strcmp函数"><a href="#strcmp函数" class="headerlink" title="strcmp函数"></a>strcmp函数</h3><p>函数原型</p><p><code>int strcmp (const char * str1, const char * str2)</code>;</p><p>作用</p><p>比较两个字符串的大小</p><p>如果字符串1&gt;字符串2，返回值&gt;0</p><p>如果字符串1&#x3D;字符串2，返回值&#x3D;0</p><p>如果字符串1&lt;字符串2，返回值&gt;0</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;1234567&quot;</span>;<br>    <span class="hljs-type">char</span> str3[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;123456789&quot;</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str1,str3));<span class="hljs-comment">//字符串1&lt;字符串2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str2,str2));<span class="hljs-comment">//字符串1=字符串2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str3,str1));<span class="hljs-comment">//字符串1&gt;字符串2</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">-1</span> <span class="hljs-comment">//字符串1&lt;字符串2，返回值&lt;0</span><br><span class="hljs-number">0</span>  <span class="hljs-comment">//字符串1=字符串2，返回值=0</span><br><span class="hljs-number">1</span>  <span class="hljs-comment">//字符串1&gt;字符串2，返回值&gt;0</span><br></code></pre></td></tr></table></figure><h3 id="strstr函数"><a href="#strstr函数" class="headerlink" title="strstr函数"></a>strstr函数</h3><p>函数声明</p><p><code>const char * strstr(const char * str1,const char * str2);</code></p><p>作用：</p><p>在str1中查找str2出现的位置</p><p>返回指向str1中第一次出现的str2的指针，如str2不是str1的一部分，则返回”NULL”</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;ABCDEFG&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;BCD&quot;</span>;<br>    <span class="hljs-type">char</span> str3[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;JOKER&quot;</span>;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(str1, str2) == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//判断str2是不是str1的子串 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,<span class="hljs-built_in">strstr</span>(str1,str2));<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(str1, str3) == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//判断str3是不是str1的子串 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,<span class="hljs-built_in">strstr</span>(str1,str3));<br>&#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">BCDEFG <span class="hljs-comment">//返回第一次出现str2(BCD)及其之后的字符</span><br>NO<span class="hljs-comment">//str3不是str1的子串</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
