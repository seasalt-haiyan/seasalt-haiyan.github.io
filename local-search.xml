<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSS 浮动布局</title>
    <link href="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
    <url>/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>在说浮动之前，我们先来了解一下<strong>标准流</strong>。</p><ul class="lvl-0"><li class="lvl-2">标准流又称为普通流，是浏览器<strong>默认</strong>的排版方式。</li><li class="lvl-2">标准流中元素会自动按照从左往右从上往下进行排列。</li></ul><h1>浮动 float</h1><p><strong>什么是浮动？</strong></p><p>使元素脱离了标准流，向左或向又移动，直到碰到父元素或另一个浮动元素的边缘为止。</p><p>最初，引入<code>float</code>属性是为了能让Web开发人员实现简单的布局，包括在一列文本中浮动的图像，文字环绕在它的左边或右边。你可能在报纸版面看到过。</p><p><strong>让盒子浮动起来</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.son1</span>&#123;<br>    <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br>&#125; //设置class为son1的盒子向左浮动<br></code></pre></td></tr></table></figure><p>参数</p><table><thead><tr><th style="text-align:center">属性值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">none</td><td style="text-align:center">元素不浮动</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">元素向左浮动</td></tr><tr><td style="text-align:center">right</td><td style="text-align:center">元素向右浮动</td></tr></tbody></table><h2 id="特性">特性</h2><ol><li class="lvl-3"><p>加了浮动的元素盒子是“浮起来”的，脱离了标准流，漂浮在其他标准盒子上，原来的位置空了下来，漏给了标准流盒子</p></li><li class="lvl-3"><p>浮动元素具有<strong>行内块元素</strong>特性</p><ol><li class="lvl-6">任何元素都可以浮动，不管之前是什么模式的元素，添加浮动之后都具有行内块元素相似的特性。</li><li class="lvl-6">元素设置浮动后，原来设置的宽高起作用，默认在当前包含块左上一排，如果前面有块级元素，会排在元素的下面。</li></ol></li></ol><img src="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/1.png" class="" title="这是图片的说明"><ol start="3"><li class="lvl-6"><p>如果原来没有设置宽高，浮动后根据内容决定大小</p></li></ol><img src="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/2.png" class="" title="这是图片的说明"><img src="/2024/02/29/CSS-%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80/3.png" class="" title="这是图片的说明"><ol start="3"><li class="lvl-3"><p>浮动的元素是相互贴靠在一起的(<strong>没有缝隙</strong>)，如果父级宽度装不下这些浮动的盒子，多出的盒子会<strong>另起一行</strong>对齐。</p></li><li class="lvl-3"><p>浮动元素<strong>不会遮挡</strong>标准流中的文字。</p></li></ol><h2 id="清除浮动">清除浮动</h2><p>我们发现，一个浮动元素会被移出正常文档流，且其他元素会显示在它的下方。如果我们不想让剩余元素也收到浮动元素的影响，我们需要<strong>清除浮动</strong></p><ul class="lvl-0"><li class="lvl-2"><p>清除浮动的本质是<strong>清除浮动造成的影响</strong></p></li><li class="lvl-2"><p>如果父盒子本身有高度，则不需要清除浮动</p></li><li class="lvl-2"><p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了。</p></li><li class="lvl-2"><p>清除浮动主要是为了解决父级元素因为子级浮动引起的内部高度为0的问题</p></li></ul><h3 id="清除浮动的方法">清除浮动的方法</h3><ol><li class="lvl-3"><p>额外标签法</p></li><li class="lvl-3"><p>父级添加<code>overflow</code>属性</p></li><li class="lvl-3"><p>父级添加<code>after</code>伪元素</p></li><li class="lvl-3"><p>父级添加双伪元素</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS Flex布局</title>
    <link href="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/"/>
    <url>/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1>flex布局的基本概念</h1><ul class="lvl-0"><li class="lvl-2">flex布局是一种一维的布局模型，它给子元素之间提供了强大的空间分布和对齐能力。</li><li class="lvl-2">我们之所以说flex是一种一维的布局，是因为一个flex容器一次只能处理一个维度上的元素布局，一行或者一列。</li><li class="lvl-2">采用flex布局的元素，称为<strong>flex容器</strong>，它的所有子元素自动成为容器成员，称为<strong>flex项目</strong>，容器存在两根轴，默认项目按照主轴排列。</li></ul><h1>flexbox的两根轴线</h1><p>当使用flex布局时，首先应该想到两根轴线——主轴和交叉轴，主轴由<code>flex-direction</code>定义，另一根轴垂直于它，flexbox的所有属性都跟这两根轴线有关。</p><p>首先，先设置flex容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;<br>    <span class="hljs-attribute">display</span>: flex | inline-flex; //块元素使用<span class="hljs-attribute">flex</span>，行内块元素使用inline-<span class="hljs-attribute">flex</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="容器属性">容器属性</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-direction</code></p></li><li class="lvl-2"><p><code>flex-wrap</code></p></li><li class="lvl-2"><p><code>flex-flow</code></p></li><li class="lvl-2"><p><code>justify-content</code></p></li><li class="lvl-2"><p><code>align-items</code></p></li><li class="lvl-2"><p><code>align-content</code></p></li></ul><h2 id="主轴">主轴</h2><p>主轴由<code>flex-direction</code>定义，可以取四个值</p><ul class="lvl-0"><li class="lvl-2"><p><code>row</code></p></li><li class="lvl-2"><p><code>row-reverse</code></p></li><li class="lvl-2"><p><code>column</code></p></li><li class="lvl-2"><p><code>column-reverse</code></p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>row和row-reverse分别是水平排列和水平逆序排列</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/1.svg" class="" title="这是图片的说明"><ul class="lvl-0"><li class="lvl-2"><p>column 和 column-reverse 分别是垂直排列和垂直逆序排列</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/2.svg" class="" title="这是图片的说明"><h2 id="交叉轴">交叉轴</h2><p>交叉轴垂直于主轴，所以如果你的<code>flex-direction</code>设置成了<code>row</code>或者<code>row-reverse</code>的话，交叉轴的方向就是沿着上下方向延伸的。</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/3.svg" class="" title="这是图片的说明"><p>如果主轴方向设成了<code>column</code>或者<code>column-reverse</code>交叉轴就是水平方向</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/4.svg" class="" title="这是图片的说明"><h1>用 flex-wrap 实现多行 Flex 容器</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-wrap</span>: no-wrap | wrap | wrap-reverse;<br></code></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>nowrap</code> （默认）不换行</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/5.png" class="" title="这是图片的说明"><ul class="lvl-0"><li class="lvl-2"><p><code>wrap</code> 换行，第一行在上方</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/6.png" class="" title="这是图片的说明"><ul class="lvl-0"><li class="lvl-2"><p><code>wrap-reverse</code> 换行，第一行在下方</p></li></ul><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/7.png" class="" title="这是图片的说明"><h1>简写属性 flex-flow</h1><p>你可以将两个属性 <code>flex-direction</code> 和 <code>flex-wrap</code> 组合为简写属性 <code>flex-flow</code>。第一个指定的值为 <code>flex-direction</code> ，第二个指定的值为 <code>flex-wrap</code>.</p><h1>元素间的对齐和空间分配</h1><p>Flexbox 的一个关键特性是能够设置 flex 元素沿主轴方向和交叉轴方向的对齐方式，以及它们之间的空间分配。</p><h2 id="align-items">align-items</h2><p><code>align-items</code>属性可以使元素在交叉轴方向对齐</p><p>这个属性的初始值为<code>stretch</code>，这就是为什么 flex 元素会默认被拉伸到最高元素的高度。实际上，它们被拉伸来填满 flex 容器——最高的元素定义了容器的高度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">align-items</span>:flex-start | flex-end | center | baseline | stretch;<br>//Streth 拉伸（子元素不设置高度时的默认值)<br></code></pre></td></tr></table></figure><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/9.png" class="" title="这是图片的说明"><h2 id="justify-content">justify-content</h2><p><code>justify-content</code>属性用来使元素在主轴方向上对齐，主轴方向是通过 <code>flex-direction</code> 设置的方向。</p><p>你可以把值设置为<code>space-between</code>，把元素排列好之后的剩余空间拿出来，平均分配到元素之间，所以元素之间间隔相等。或者使用<code>space-around</code>，使每个元素的左右空间相等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;<br></code></pre></td></tr></table></figure><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/8.png" class="" title="这是图片的说明"><h1>flex元素上的属性</h1><p>为了更好地控制flex元素，有四个属性可以作用于他们：</p><ul class="lvl-0"><li class="lvl-2"><p><code>order</code></p></li><li class="lvl-2"><p><code>flex-grow</code></p></li><li class="lvl-2"><p><code>flex-shrink</code></p></li><li class="lvl-2"><p><code>flex-basis</code></p></li></ul><p>在考虑这几个属性的作用之前，需要先了解一下<strong>可用空间</strong>这个概念，这几个flex属性其实就是改变了flex容器中的可用空间的行为，同时，可用空间对于flex元素的对齐行为也是很重要的。</p><p>假设在 1 个 500px 的容器中，我们有 3 个 100px 宽的元素，那么这 3 个元素需要占 300px 的宽，剩下 200px 的可用空间。在默认情况下，flexbox 的行为会把这 200px 的空间留在最后一个元素的后面。</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/10.svg" class="" title="这是图片的说明"><p>如果期望这些元素能自动地扩展去填充满剩下的空间，那么我们需要去控制可用空间在这几个元素间如何分配，这就是元素上的那些 flex 属性要做的事。</p><h2 id="order属性">order属性</h2><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><img src="/2024/02/28/CSS-flex%E5%B8%83%E5%B1%80/11.png" class="" title="这是图片的说明"><h2 id="Flex-元素属性：flex-grow">Flex 元素属性：flex-grow</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p></li><li class="lvl-2"><p>如果容器压根就没有剩余空间，那么即使设置了<code>flex-grow</code>也不会生效。</p></li><li class="lvl-2"><p><code>flex-grow</code>的默认值是0，子项目不做任何比例拉伸，如果将三个子项目的flex-grow属性都设为1，那么他们将按照1:1:1的比例分配剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p></li></ul><h2 id="Flex-元素属性：flex-shrink">Flex 元素属性：flex-shrink</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p></li><li class="lvl-2"><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p></li><li class="lvl-2"><p>负值对该属性无效，如果容器还有剩余空间，同样设置<code>flex-shrink</code>也是无效的。</p></li><li class="lvl-2"><p>如果不希望压缩，我们可以选择换行，只需要设置<code>flex-wrap</code>为<code>wrap</code>就好。</p></li></ul><h2 id="Flex-元素属性：-flex-basis">Flex 元素属性： flex-basis</h2><ul class="lvl-0"><li class="lvl-2"><p><code>flex-basis</code> 定义了该元素的空间大小，flex 容器里除了元素所占的空间以外的富余空间就是可用空间。该属性的默认值是 <code>auto</code>。此时，浏览器会检测这个元素是否具有确定的尺寸。在上面的例子中，所有元素都设定了宽度（width）为 100px，所以 <code>flex-basis</code> 的值为 100px。</p></li><li class="lvl-2"><p>如果没有给元素设定尺寸，<code>flex-basis</code> 的值采用元素内容的尺寸。这就解释了：我们给只要给 Flex 元素的父元素声明 <code>display: flex</code>，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</p></li></ul><h2 id="Flex属性的简写">Flex属性的简写</h2><ul class="lvl-0"><li class="lvl-2"><p>flex属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p></li><li class="lvl-2"><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p></li><li class="lvl-2"><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法——冒泡排序</title>
    <link href="/2023/11/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/11/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>冒泡排序(Bubble Sort)是一种简单，直观的排序算法，它通过比较相邻两个数据，按照从小到大或者从大到小的顺序进行交换，就像一个泡泡冒上去一样，故得名冒泡排序</p></blockquote><h1 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h1><p>以从小到大为例，冒泡算法是这样实现的：</p><p>遍历原始数据，从第一个数开始，到<strong>倒数第二个</strong>数结束，比较当前数和下一个数的大小，如果当前数比下一个数大，则交换这两个数，这样可以将最大的数转移到末尾，接下来再次遍历，但到<strong>倒数第三个</strong>数结束，可以将第二大的数转移到倒数第二位，以此类推。</p><p>动图演示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="动图演示"></p><p>优点：空间复杂度低，稳定性高</p><p>缺点：时间复杂度，效率低</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bubblesort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span> i, j, temp;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<span class="hljs-comment">//外部循环 </span><br><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n - i; j++)&#123;<span class="hljs-comment">//内部循环 </span><br><span class="hljs-keyword">if</span>(a[j] &gt; a[j + <span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//比较相邻元素大小 </span><br>temp = a[j];<span class="hljs-comment">//交换值 </span><br>a[j] = a[j + <span class="hljs-number">1</span>];<br>a[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<span class="hljs-comment">//写入数据 </span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>&#125;<br>bubblesort(a,<span class="hljs-number">10</span>);<span class="hljs-comment">//排序 </span><br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<span class="hljs-comment">//输出数据 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>&#125;<br> <br>&#125; <br></code></pre></td></tr></table></figure><p>输入数据</p><p><code>2 4 1 3 7 9 6 5 8 10</code></p><p>输出数据</p><p><code>1 2 3 4 5 6 7 8 9 10</code></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言库函数(快速排序)--qsort()</title>
    <link href="/2023/11/20/C%E8%AF%AD%E8%A8%80%E5%BA%93%E5%87%BD%E6%95%B0-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-qsort/"/>
    <url>/2023/11/20/C%E8%AF%AD%E8%A8%80%E5%BA%93%E5%87%BD%E6%95%B0-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-qsort/</url>
    
    <content type="html"><![CDATA[<blockquote><p>qsort()函数是一种用于对数组快速排序的函数，他是一个通用的排序函数，支持对不同类型的元素进行排序</p></blockquote><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>qsort()是包含在C语言标准库&lt;stdlib.h&gt;中的函数，所以想使用该函数应在程序前引用该头文件</p><p><code>#include &lt;stdlib.h&gt;</code></p><h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><p><code>void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</code></p><ul><li><p>base -&gt; 数组名</p></li><li><p>nitems -&gt;元素个数</p></li><li><p>size -&gt; 数组元素所占字节（int,char等所占字节）</p></li><li><p>(*compar)(const void <em>, const void</em>) -&gt; 排序原则（递增，递减等）</p><h2 id="排序原则？"><a href="#排序原则？" class="headerlink" title="排序原则？"></a>排序原则？</h2><p>通过定义一个函数compar，通过这个函数<strong>返回的参数</strong>来去确定排序规则</p><p><strong>注意</strong>：compar函数中参数需要以<strong>const void *a,const void *b**的形式来定义，表示a，b的类型是“未确定”（void），在return时候进行强制类型转换为int型，</strong>*(int*)a-*(int*)b**表示递增顺序，如果递减只需要更换a和b的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> &#123;<br><span class="hljs-keyword">return</span> *(<span class="hljs-type">int</span>*)a-*(<span class="hljs-type">int</span>*)b;<span class="hljs-comment">//递增</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="不同类型元素排序"><a href="#不同类型元素排序" class="headerlink" title="不同类型元素排序"></a>不同类型元素排序</h1><p>对于不同的类型，只需要改变compar函数就可以</p><h2 id="整形（int）"><a href="#整形（int）" class="headerlink" title="整形（int）"></a>整形（int）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">int</span>*)a-*(<span class="hljs-type">int</span>*)b;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点型（double）"><a href="#浮点型（double）" class="headerlink" title="浮点型（double）"></a>浮点型（double）</h2><p><strong>注意！浮点数存在精度损失<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="浮点数并不精确，5.000实际上可能是5.000000000003">[1]</span></a></sup>的问题，运算可能会出错，所以我们选择比较的方式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">double</span>*)a&gt;*(<span class="hljs-type">double</span>*)b?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>;<span class="hljs-comment">//三目运算符，如果前大于后，输出1，反之输出-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符型（char）"><a href="#字符型（char）" class="headerlink" title="字符型（char）"></a>字符型（char）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">char</span>*)a-*(<span class="hljs-type">char</span>*)b;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>升序排序一个10位数数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-type">int</span> <span class="hljs-title function_">compar</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-type">int</span>*)a-*(<span class="hljs-type">int</span>*)b;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>&#125;;<br>    qsort(a,<span class="hljs-number">10</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>),compar);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><p><code>1 2 3 4 5 6 7 8 9 10</code></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>浮点数并不精确，5.000实际上可能是5.000000000003<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言中常用的字符串函数</title>
    <link href="/2023/11/20/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/"/>
    <url>/2023/11/20/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>想要在c语言中处理字符串，你需要引用&lt;string.h&gt;头文件</li></ul><h2 id="处理字符串的函数"><a href="#处理字符串的函数" class="headerlink" title="处理字符串的函数"></a>处理字符串的函数</h2><h3 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h3><p>函数声明<br><code>size_t strlen (const char *str);</code></p><p>作用：</p><p>返回字符串的长度（’\0’之前的长度，不包括’\0’）</p><p><strong>注意</strong>：</p><p>参数指向的字符串必须要以‘\0’结束</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;hello&quot;</span>;<br>    n = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为5。</p><h3 id="strcpy函数"><a href="#strcpy函数" class="headerlink" title="strcpy函数"></a>strcpy函数</h3><p>函数声明</p><p><code>char * strcpy(char * destination,const * source);</code></p><p>作用：</p><p>把source字符串的内容复制到destination中</p><p><strong>注意</strong>：</p><p>目标空间必须足够大能够存放源字符串</p><p>目标空间不可为”const”</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;world&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str1);<span class="hljs-comment">//操作前的str1</span><br>    <span class="hljs-built_in">strcpy</span>(str1,str2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str1);<span class="hljs-comment">//操作后的str1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">hello<span class="hljs-comment">//操作前的str1</span><br>world<span class="hljs-comment">//操作后的str1，strcpy将后面（str2）的值给了str1</span><br></code></pre></td></tr></table></figure><h3 id="strcat函数"><a href="#strcat函数" class="headerlink" title="strcat函数"></a>strcat函数</h3><p>函数声明</p><p><code>char * strcat(char * destination, const char * source)</code>;</p><p>作用：</p><p>将source的内容拼接到destination上</p><p><strong>注意</strong>：</p><p>destination空间必须足够大</p><p>destination不能为”const”</p><p>不可以自己给自己拼接</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">20</span>]=<span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;world&quot;</span>;<br>    <span class="hljs-built_in">strcat</span>(str1,str2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str1);<br>    <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><p><code>helloworld</code></p><h3 id="strcmp函数"><a href="#strcmp函数" class="headerlink" title="strcmp函数"></a>strcmp函数</h3><p>函数原型</p><p><code>int strcmp (const char * str1, const char * str2)</code>;</p><p>作用</p><p>比较两个字符串的大小</p><p>如果字符串1&gt;字符串2，返回值&gt;0</p><p>如果字符串1&#x3D;字符串2，返回值&#x3D;0</p><p>如果字符串1&lt;字符串2，返回值&gt;0</p><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;1234567&quot;</span>;<br>    <span class="hljs-type">char</span> str3[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;123456789&quot;</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str1,str3));<span class="hljs-comment">//字符串1&lt;字符串2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str2,str2));<span class="hljs-comment">//字符串1=字符串2</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">strcmp</span>(str3,str1));<span class="hljs-comment">//字符串1&gt;字符串2</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">-1</span> <span class="hljs-comment">//字符串1&lt;字符串2，返回值&lt;0</span><br><span class="hljs-number">0</span>  <span class="hljs-comment">//字符串1=字符串2，返回值=0</span><br><span class="hljs-number">1</span>  <span class="hljs-comment">//字符串1&gt;字符串2，返回值&gt;0</span><br></code></pre></td></tr></table></figure><h3 id="strstr函数"><a href="#strstr函数" class="headerlink" title="strstr函数"></a>strstr函数</h3><p>函数声明</p><p><code>const char * strstr(const char * str1,const char * str2);</code></p><p>作用：</p><p>在str1中查找str2出现的位置</p><p>返回指向str1中第一次出现的str2的指针，如str2不是str1的一部分，则返回”NULL”</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str1[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;ABCDEFG&quot;</span>;<br>    <span class="hljs-type">char</span> str2[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;BCD&quot;</span>;<br>    <span class="hljs-type">char</span> str3[<span class="hljs-number">10</span>]=<span class="hljs-string">&quot;JOKER&quot;</span>;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(str1, str2) == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//判断str2是不是str1的子串 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,<span class="hljs-built_in">strstr</span>(str1,str2));<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(str1, str3) == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//判断str3是不是str1的子串 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,<span class="hljs-built_in">strstr</span>(str1,str3));<br>&#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">BCDEFG <span class="hljs-comment">//返回第一次出现str2(BCD)及其之后的字符</span><br>NO<span class="hljs-comment">//str3不是str1的子串</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
